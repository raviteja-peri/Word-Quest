httpng binary wire protocol wdhttpngwire httpng binary wire protocol wc working draft  july  this version httpwwwworgtrwdhttpngwire latest version httpwwwworgtrwdhttpngwire authors bill janssen xerox parc janssen@parcxeroxcom copyright   wc mit inria keio  all rights reserved wc liability trademark document use and software licensing rules apply  status of this document this is a wc working draft for review by wc members and other interested parties it is a draft document and may be updated replaced or obsoleted by other documents at any time it is inappropriate to use wc working drafts as reference material or to cite them as other than work in progress a list of current wc technical reports can be found at httpwwwworgtr this document has been produced as part of the wc httpng activity this is work in progress and does not imply endorsement by or the consensus of either wc or members of the httpng protocol design working group we expect the document to evolve as we get more data from the web characterization group describing the current state of the web this document describes a binary onthewire protocol to be used when sending httpng operation invocations or terminations across a network connection it is part of a suite of documents describing the httpng design and prototype implementation httpng short and longterm goals wd httpng architectural model wd httpng wire protocol wd the classic web interfaces in httpng wd the mux protocol wd description of the httpng testbed note please send comments on this specification to wwwhttpngcomments@worg  syntax used in this document two data description languages are used in this document the first called isl is an abstract language for defining data types and interfaces it is described in the ilu manual the second is a pseudoc syntax it should be interpreted as c data structure layouts without any automatic padding to size boundaries and allowing arbitrary bitsize limits on structs and unions as well as on ints and enums each use of isl and pseudoc is marked as to which language is being used  model of operation this protocol assumes a particular model of operation based on conventional rpc technology with certain variations the basic idea is that clients make use of services exported from a server by invoking operations on objects resident in that server the client is connected to the server by a connection which carries operation invocation requests from the client known as the caller to the server known as the callee and operation results from the callee back to the caller multiple connections can exist simultaneously between the same client and server the connection has state associated with it which allows the caller and callee to use shorthand notations for some of the data passed to the other party two rpc messages are defined by this protocol the request which is used by the caller to invoke an operation on the callee and the reply which is used to transfer operation results from the callee to the caller every reply message is associated with a particular request message but not every request message has a reply message associated with it connections are directional operation invocation requests always flow from the caller to the callee replies always flow from the callee to the caller in addition to the rpc messages several control messages are defined for this protocol these control messages are used to improve the efficiency and robustness of the connection they are intended to be generated and consumed by the implementation of the wire protocol and should have no direct effect on the applications using the protocol a request message indicates two important elements the operation and the discriminant object or discriminant it also contains data values which are the input parameters to the operation the model used here assumes that operations are grouped into sets the elements of which have a welldefined ordering each operation set is called an interface it further assumes that an interface can be identified by a urn which also a uuid and that each operation in an interface can be identified with the ordinal number of the operation within the ordering of the elements of the interface it assumes that every discriminant object can be identified with an object id also a urn and uuid it provides for the fact that with most distributed object systems all of the discriminants available at a particular server share a common prefix to their object id this is called the server id note that this characteristic is not required but the protocol provides an efficiency optimization for the case where it is true in such a case we call the portion of the object id not contained in the server id the instance handle each request has an implicit connectionspecific serial number associated with it serial numbers begin with the value one  and have a maximum value of  when the maximum serial number of a connection has been reached the connection must be terminated and further operations must be invoked over a new connection a reply message indicates the termination status of the operation provides information about synchronization and may contain data values which are output parameters or return values from the operation it contains an explicit serial number to indicate which request it is a reply to replies may either indicate successful completion of the operation or several different kinds of exceptional termination if an exception is signalled additional information is passed to indicate which of the possible exceptions for the operation was raised the model assumes that the messages are carried back and forth between the two parties by a transport subsystem it requires that the transport subsystem be reliable sequenced and messageoriented by reliable we mean that after a message is handed to the transport the transport will either deliver it to the other party or will signal an error if its reliable delivery cannot be ascertained by sequenced we mean that the transport will deliver messages to the other party in the same order in which the sender handed them to the transport by messageoriented we mean that the transport will provide indication of the beginning and ending of the messages without reference to any data encoded inside the message an example of this type of transport would be the record marking defined in internet rfc  used with tcpip  global issues  byte order all values use network standard byte order ie bigendian because all internet protocols use it if in the future this becomes a problem for the internet this protocol will be affected by whatever solution is used to solve the problem in the wider internet context note that the data marshalling format defined in internet rfc  which this protocol incorporates by reference is also defined to be a bigendian protocol  alignment and padding the marshalled form of each value begins on a bit boundary the marshalled form of each value is paddedafter if necessary to the next bit boundary the padding bits may be either  or  in any combination  marshalling format marshalling is via the xdr format specified in internet rfc  it could be argued that this format is inexcusably wasteful with certain value types such as boolean  bits or byte  bits and that a bit or bit oriented format should be designed and used in its place however the argument of using an existing internet standard for this purpose rather than inventing a new one is a strong one a new format should only be defined if measurement of the overhead shows gross waste  security this protocol assumes that security provisions are made either at some level above it typically in the application interfaces or at some level below it typically by use of a secure transport mechanism it contains no protocollevel mechanisms for providing or assuring any of the concerns normally related to security  session context unlike some previous protocols this protocol is sessionoriented that means that individual messages are sent in the context of a session and are contextsensitive this contextsensitivity allows sessionwide compression however to support various kinds of marshalling architectures in implementations of this system all marshalling can be done in a contextinsensitive fashion at the expense of sending additional bytes across the wire however unmarshalling implementations must always be capable of tracking and using contextsensitive information  utility types the following data structures are defined in pseudoc typedef enum  false   true   booleantypedef enum  initializeconnection   terminateconnection   defaultcharset   controlmsgtypetypedef enum  success   userexception                occurred during operation  systemexceptionbefore        occurred before beginning operation  systemexceptionafter          occurred after beginning operation  replystatustypedef struct  boolean cached_disc          true if cached object key  union   struct    boolean cache_key          true if both sides cache it    unsigned key_len          length of key bytes    uncached_key  unsigned cache_index       cache index if cached   v discriminantidtypedef struct  boolean cached_op            true if cached id  union   struct    boolean cache_operation    true if should be cached    unsigned method_id        method index    uncached_op_info  unsigned cache_index       cache index if cached_op set   v operationidtypedef enum  mangledmessage               bad protocol synchronization  processfinished              sending party has exitted  resourcemanagement           transient close  wrongcallee                  bad server id received  maxserialnumber               the maximum serial number was used  terminationcausetypedef struct  unsigned major        unsigned minor   protocolversiontypedef unsigned unused  messages only a few messages are defined the initializeconnection message is used by the caller to verify that it has connected to the right server and that it is using the correct version of the wire protocol the defaultcharset message allows both sides to independently define a default value for string charsets the request message causes an operation to be started on the remote server the reply message is sent from the server to the client to inform it of the completion status of the operation and to convey any result values the terminateconnection message allows either side to indicate graceful shutdown of a connection  extension headers this protocol uses a feature called an extension header to provide for extensibility and tailorability features such as serialization contexts or global thread identifiers may be implemented via this feature an extension header is an encapsulated value of the isl type extensionheader each request message and reply message may contain a value of type extensionheaderlist which contains a number of extension headers the following isl fragment decribes the types extensionheaderlist and extensionheader interface httpngwng imports httpng end brand httpngworgtype simplestring  string language idefault limit xfffftype cinfostring  string language ihttpngcinfo limit xfffftype extensionheader  record     name  httpnguuidstring     value  pickleendtype extensionheaderlist  sequence of extensionheader  request message request header pseudoc typedef struct   boolean control_msg            false   boolean ext_hdr_present       true if ext hdr list present   operationid operation_id     identifies operation   discriminantid object_key    identifies discriminant  requestmsgheader                  bytes total  the actual message consists of the following sections  requestmsgheader   extension header list if any   xdr string containing object type id of object type defining operation if not cached   bytes of object_key if not cached padded to  byte boundary   explicit input parameter values if any padded to a  byte boundary  the operation_id contains either a connectionspecific bit cache index or a bit method id the zerobased ordinal position of the method in the isl declaration of the object type in which the operation is defined of the operation if the method id is given an additional value an xdr string value containing the object type id of the object type in which the operation is defined is also passed this means that this protocol will not support interfaces in which object types have more than  methods directly defined the object_key is either a bit connectionspecific cache index or the length of a variable length octet sequence of  or fewer bytes containing the servicepointrelative name for the object the instancehandle of the url the object key value of  false false   normally a zero byte variable length object key is reserved for use by the protocol the object_key is marshalled onto the transport as an xdr value of type fixedlength opaque data where the length is that specified in the vkey_len field of the object_key  operation and object memoizing callers may reduce the size of messages by memoizing operation ids and object ids that are passed in the connection this is done by the caller setting the cache_key for object ids or cache_operation for operation ids bit in the discriminantid or operationid struct when the object key or operation id is first sent each side must then assign the next available index to that object or operation the space of operations is separate from the space of object ids so that a total of  possible values is available for memoizing of discriminant objects and  different possible values for memoizing of operations note that the index is passed implicitly so both sides of the connection must synchronize their use of indices a shared set of indices may be loaded into the connection by some mechanism before any messages are sent this specification does not define a mechanism for doing so  reply message reply header pseudoc typedef struct   boolean control_msg            false   boolean ext_hdr_present       true if ext hdr list present   replystatus    unused reply_    unsigned serial_no           serial  from request  replymsgheader                   bytes total  the actual message consists of the following fields  replymsgheader   extension header list if any   exception id bit unsigned if any   explicit output parameter values if any padded to  byte boundary   initializeconnection message initializeconnection header pseudoc typedef struct   boolean control_msg            true   controlmsgtype msg_type        initializeconnection   unused verify_    protocolversion version       what version of the protocol   unsigned server_id_len       length of server id  initializeconnectionmsgheader the actual message consists of the following fields  initializeconnectionmsgheader   server_id_lenlength server id for supposed callee padded to byte boundary  this message is sent from caller to callee as the first message of the connection it is used to pass the server id of the connection from client to server so that both sides understand what the omitted prefix portion of discriminant ids is if the server id received by the callee is not the correct server id for the callee ie the callee has objects which do not have that prefix in their object ids the callee should terminate the connection with the appropriate reason the server id is passed as an xdr fixedlength opaque data value of the length specified in server_id_len  terminateconnection message terminateconnection header pseudoc typedef struct   boolean control_msg            true   controlmsgtype msg_type        terminateconnection   terminationcause cause        why connection terminated   unsigned serial_no           last request processedsent  terminateconnectionmsgheader the actual message consists simply of the header it provides for graceful connection shutdown it is sent either from the caller to the callee or from the callee to the caller and informs the other party that it is cancelling the connection for one of these reasons a badly formatted message has arrived from the other party and protocol sychronization is believe lost or the caller has sent a initializeconnection message with the wrong major version for the protocol this party process thread whatever is going away and the other party should not attempt to reconnect to it this connection is being terminated due to active resource management the other party should attempt to reconnect if it needs to  this reason is typically only useful from callee to caller the caller has sent a initializeconnection message with the wrong server id the caller has used the maximum serial number available for this connection the serial_no field contains the serial number of the last message completely processed by the caller when terminateconnection is sent from caller to callee or the serial number of the last message sent by the callee when sent from callee to caller no further messages should be sent on the connection by a sender of a terminateconnection message after it has been sent or by a receiver of terminateconnection messsage after it has been received  defaultcharset message defaultcharset header pseudoc typedef struct   boolean control_msg            true   controlmsgtype msg_type        defaultcharset   unused bits_               unused   unsigned charset_mibenum     default charset  defaultcharsetmsgheader this message is sent by either side of a connection to establish a default charset for subsequent messages sent by that side of the connection the charset defines how string values are marshalled as octet sequences the default charset defines the default marshalling unless overridden by an explicit charset in a string value each side of the connection may establish a default charset independently of the other side of the connection the default charset only applies to string values in messages coming from that side a new value of the default charset may be established at any time by sending another defaultcharset message  data marshalling the data value format used for parameters is the xdr format specified in internet rfc  however we extend the xdr specification with one additional type called flagged variablelength opaque data it is similar to xdrs regular variablelength opaque data except that the highorder bit of the length field is used as a flag bit instead of being part of the length this means that flagged variablelength opaque data can only carry opaque data of lengths less than or equal to                                                    flag        length n       bytebyte n           bit              bitsn bytesr bytes                                 nr where nr mod                                             flagged variablelength opaque  boolean type values of type boolean are passed as xdr bool  enumeration types values of enumeration types are passed as xdr enum each enumeration value is assigned its ordinal value as it appears in the declaration of the enumeration type starting with the value one  numeric types  fixedpoint types values of fixedpoint types are passed by passing the value of the numerator we define a number of special cases for efficient marshalling of common integer types as well as a general case for passing values of fixedpoint types that are not covered by the special cases special cases bit integer fixedpoint values with a minimumnumerator value greater than or equal to  and with a minimum numerator value less than or equal to  are passed as xdr integer bit unsigned integer fixedpoint values with a minimumnumerator value greater than or equal to  and with a maximum numerator less than or equal to  are passed as xdr unsigned integer bit integer fixedpoint values with a with a minimum numerator value greater than or equal to  and with a maximum numerator less than or equal to are passed as xdr hyper integer bit unsigned integer fixedpoint values with a minimumnumerator value greater than or equal to  and with a maximum numerator value less than or equal to  are passed as xdr unsigned hyper integer general case the numerator of the value is passed as xdr flagged variablelength opaque data with the bytes of the data containing the value expressed as a base number in bigendian order that is with the most significant digit of the value first the flag bit is used to carry the sign the flag bit is  for a positive number or zero and  for a negative number  floatingpoint types we define a number of special cases for efficient marshalling of common floatingpoint types as well as a general case for passing values of floatingpoint types that are not covered by the special cases special cases ieee single floating point types matching the ieee bit floatingpoint format that is with the parameters significandsize exponentbase maximumexponentvalue minimumexponentvalue hasnotanumbertrue hasinfinitytrue denormalizedvalueallowedtrue and hassignedzerotrue are passed as xdr floatingpoint ieee double floating point types matching the ieee bit floatingpoint format that is with the parameters significandsize exponentbase maximumexponentvalue minimumexponentvalue hasnotanumbertrue hasinfinitytrue denormalizedvalueallowedtrue and hassignedzerotrue are passed as xdr doubleprecision floatingpoint intel extended double floating point types matching the intel ieee floatingpointcompliant extended double floatingpoint format that is with the parameters significandsize exponentbase maximumexponentvalue minimumexponentvalue hasnotanumbertrue hasinfinitytrue denormalizedvalueallowedtrue and hassignedzerotrue are passed as a byte value of xdr fixedlength opaque data containing the floatingpoint value in the format specified in the unix system v application binary interface intel  processor supplement intel abi document the  bits of the fraction occupy the first  bytes in littleendian order plus the low seven bits of the eighth byte the  bit explicit leading significand bit occupies the highorder bit of the eighth byte the  bits of the exponent occupy the ninth byte and the loworder bits of the tenth byte in littleendian order the sign bit occupies the highorder bit of the tenth byte the eleventh and twelfth bytes are unused and should contain zero values sparc  powerpc extended double floating point types matching the xdr quadrupleprecision floatingpoint format that is with the parameters significandsize exponentbase maximumexponentvalue minimumexponentvalue hasnotanumbertrue hasinfinitytrue denormalizedvalueallowedtrue and hassignedzerotrue which is the form of extended double floatingpoint used by powerpc and sparc processors are passed as xdr quadrupleprecision floatingpoint general case values of floatingpoint types not matching the special cases identified above are passed as a value of the xdr struct type generalfloatingpointvalue which has the following definition  xdr enum  normal   notanumber   infinity    floatingpointvaluetypestruct   flagged opaque fixedpointsignandsignificand  flagged opaque fixedpointexponent normalfloatingpointvalueunion switch floatingpointvaluetype disc   case normal normalfloatingpointvalue value  case notanumber void  case infinity void generalfloatingpointvalue the two fields of the normalfloatingpointvalue struct each contain an onthewire representation of a fixedpoint value of the fixedpoint type denominator nomininumnumerator nomaximumnumerator the fixedpointsignandsignificand field contains the sign of the floatingpoint value as the sign and the actual significand as the absolute value of the fixedpoint value the fixedpointexponent field contains the exponent of the floatingpoint value  string types each string value sent in this protocol has a charset rfc  associated with it identified by the charsets ianaassigned mibenum value each side of a session may establish a default charset by sending the defaultcharset message string values that use the default character set do not contain explicit charset information string values that use a charset other than the default charset contain the mibenum value for the charset along with the bytes of the string we send a string value as a value of xdr flagged variablelength opaque data if the flag bit is  the first two bytes of the string value are the mibenum of the charset highorder byte first the remaining bytes are the bytes of the string if the flag bit is  the bytes of opaque data simply contain the bytes of the string the charset is the default charset for the session it is a marshalling error to send a string value with a flag bit of  over a session for which no default charset has been established to avoid contextsensitivity in marshalling a string it is always valid to marshal a string with an explicit charset value even if the charset value is the same as the default charset for the session when marshalling a string into a pickle the charset should always be explicitly included  sequence types values of sequence types are passed as xdr variablelength arrays with one exception sequences of any fixedpoint type with a minimum numerator greater than or equal to  and a maximum numerator less than or equal to  are passed as xdr variablelength opaque data with one numerator value per octet  array types values of array types are passed as xdr fixedlength arrays with one exception arrays of any fixedpoint type with a minimum numerator greater than or equal to  and a maximum numerator less than or equal to  are passed as xdr fixedlength opaque data with one numerator value per octet values of array types are passed as xdr fixedlength arrays with one exception  record types values of record types are passed as xdr struct  union types values of union types are passed as xdr union with the union discriminant being the zerobased ordinal value for the encapsulated values type  pickle type a pickle is passed as an xdr variablelength opaque data containing the type id of the pickled values type followed by the xdrmarshalled pickled value to save pickle space for common value types used in metadata we define a packed format for the type id marshalling a type id is marshalled into a pickle as a bit header in an xdr unsigned integer possibly followed by an xdr fixedlength opaque data containing the string form of the type id of the pickled type the header has the following internal structure  pseudoc typedef struct   unsigned              version    pickletypekind        type_kind    unsigned              type_id_len   typeidheader the version field gives the version number of the pickle format the type_kind field contains a value from the enum  pseudoc typedef enum   typekind_unconstrained      anything not covered by other type kinds   typekind_boolean    boolean   typekind_s   fixedpoint denom minnum maxnum   typekind_s   fixedpoint denom minnum maxnum   typekind_s        fixedpoint denom minnum maxnum   typekind_s   fixedpoint denom minnum   maxnum   typekind_u         fixedpoint denom minnum maxnum   typekind_u   fixedpoint denom minnum maxnum   typekind_u   fixedpoint denom minnum maxnum   typekind_u   fixedpoint denom minnum maxnum   typekind_ieee_float      floatingpoint significandsize exponentbase   maximumexponentvalue minimumexponentvalue   hasnotanumbertrue hasinfinitytrue   denormalizedvalueallowedtrue hassignedzerotrue   typekind_ieee_float      floatingpoint significandsize exponentbase                                   maximumexponentvalue minimumexponentvalue                                   hasnotanumbertrue hasinfinitytrue                                   denormalizedvalueallowedtrue hassignedzerotrue   typekind_i_default_str     string languageidefault   typekind_object            local or remote object      other types like date etc should be added here    pickletypekind if the value of type_kind is typekind_unconstrained the value of type_kind_len is the length of a value of xdr type fixedlength opaque data containing the full string type id of the type which immediately follows the header otherwise no opaque data is marshalled for the purposes of marshalling pickles have no default charset this means that strings marshalled into a pickle should always contain an explicit charset pickles should be considered a single message for the purposes of marshalling aliased reference types  reference types  optional types optional types are passed as xdr optionaldata  aliased types the scope of aliasing in this protocol is the message as in java rmi rather than the call as in dce rpc that is aliasing occurs only within the context of a single invocation or result rather than across a full invocationresult pair for the purposes of marshalling a pickle scope should be considered a single message scope each unique value of an aliased type that is marshalled is assigned a bit unsigned integer value unique in the scope of aliasing called its aliased identifier this identifier is marshalled as an xdr unsigned integer if the aliased value has not previously been sent in this scope its value is then marshalled as a value of its base type would be note that this means that the full value of every aliased type is sent only once in a scope subsequent occurrences send only the aliased identifier  xxx  how to handle overflow of aliased value cache   object types an instance of an object type is passed as the state of the object type which also contains information about the actual type of the value for remote object types this state is followed by the object identifier and optionally information about how the instance may be contacted  parameter type versus actual type when marshalling the state of an object its important to distinguish two important types of the value the parameter type which is the type that both sides of the session expect the value to have and the actual type of the value which is the mostderived type of the object and may be a subtype of the parameter type if the actual type is different from the parameter type extra information must be passed along with the value to allow the receiver to properly distinguish the type and its associated data however if the actual type is the same as the parameter type some of this information can be omitted  passing the actual type id we pass the state of the object type as the type id of the mostderivedtype of the object followed by the state attributes of each type of the object the type id is passed as one of three values depending on the following conditions if the parameter type of the object is sealed both sides already know the mostderivedtype id of the instance and know that the actual type must be the same as the parameter type in this case the type id is passed as xdr void if the actual type of the object is the same as the parameter type this is indicated by passing a zerolength value of xdr variablelength opaque data otherwise the type id is passed as a value of xdr variablelength opaque data containing the type id  passing the state attributes the state attributes are marshalled in one of two ways if the actual type of the instance is the same as the parameter type the state of each of the types of the object are passed by walking the supertype inheritance tree of the instance in a depthfirst order passing the value of each attribute of any particular state in the order in which they are defined as if each state formed an xdr structure with the attributes as the components of the structure the value of each attribute is marshalled directly according to the type of the attribute if the actual type of the instance is a subtype of the parameter type the receiver has to be able to handle state for types it has no knowledge of to allow for this the state of each type is passed as an encapsulation that is the state of the instance is passed as a sequence of xdr structure values each containing the state for one of the types of the instance types of the instance which have no associated state do not appear in this sequence an xdr expression of the sequence would be the following  xdr struct   opaque type_idxffff  opaque state typestatetypedef typestate statesequence the type_id field contains the type id for that type of the the object value the variablelength opaque data field state contains the values of the attributes of the state marshalled as an xdr structure where the components of the structure are the attributes of the state  passing the object id and contact info in the case of a remote object type the server id instance handle and contact info for the value are passed as a value of the following xdr structure type remoteobjectinfo  xdr typedef string contactinfoxffffstruct   opaque server_id  opaque instance_handle  contactinfo cinfos remoteobjectinfo where server_id is a identifier for the server which supports the desired object and instance_handle is a serverrelative name for the object the cinfos field contains zero or more pieces of information about the way in which the object needs to be contacted including information such as whether various transport layers are involved  system exceptions  unknownproblem exception code  isl values none an unknown problem occurred  implementationlimit exception code  isl values none the request could not be properly addressed because of some implementation resource limit on the callee side  switchconnectioncinfo exception code  isl values newcinfo  httpngwngcinfostring this exception requests the caller to upgrade the connection protocol and transport information to the cinfo specified as the argument and retry the call this is the equivalent of the upgrade message in http  and the relocate_reply message in corba giop  marshal exception code  isl values none a marshalling problem was encountered  nosuchobjecttype exception code  isl values none the object type of the operation was unknown at the server  nosuchmethod exception code  isl values none the object type of the operation was known at the server but did not contain the indicated method  nosuchobject exception code  isl values none the specified discriminant object was not available at the server  invalidtype exception code  isl values none the object specified by the discriminant did not participate in the type specified in the operation  rejected exception code  isl values reason  optional simplestring the server refused to process the request it may return a string giving a reason for the rejection  operationordiscriminantcacheoverflow exception code  isl values none the request caused the receivers cache of operations or discriminants to overflow the sender may retry the request with uncached operation and discriminant values subsequent requests should not cache any additional operation or discriminant values but may continue to use previously successfully cached values  discussion  serial numbers does this protocol need to assign serial numbers to requests and replies we do so in order to be able to cancel operations by serial number and to be able to return reply messages out of order the first problem that of cancelling operations could be dealt with by keeping track of serial numbers implicitly and using an explicit serial number only in the cancelrequest message doing this would imply that the replies would have to be returned in the order in which the requests were passed but would allow us to have  byte request messages  bytes if we count the discriminant as part of the arguments instead of part of the header and  byte reply messages thus the only real purpose for serial numbers is to allow replies to be returned out of order and possibly to make debugging the protocol easier there are other deeper unanswered questions here about the serialization semantics of the protocol for instance should the callee wait until dispatching a reply to one request until beginning to process the next one the current answer to these questions is that it is highly useful to allow a threaded callee to process multiple requests in parallel and to allow it to return requests out of order thus serial numbers are useful we assume that higherlevel protocols desiring serialization will provide a serialization context as part of the context of the call and that serialization will be handled at either a higher or lower level  memoizing of pickle and object types a great deal of the traffic over this protocol may consist of values of type pickle the equivalent of objectbyvalue or of https mimeencapsulated body type or of some object type it is tempting to introduce a form of memoizing for these value types similar to that used for request discriminants there are two reasons not to do so xdr provides no explicit support for memoizing which means that we would have to provide a marshalling format for these types which has no clean layering onto xdr for instance it might be possible to pass an object value as an xdr bit unsigned integer with the following private pseudoc structure struct   boolean   use_cached_value    boolean   cache_this_value    union     unsigned int url_len      unsigned int cache_key     v either by itself if use_cached_value is set or followed by an xdr fixed length opaque value containing the url for the object if use_cached_value is not set this type of variable structure has no equivalent in xdr on the other hand it could well be argued that since we are marshalling an object type something not explicitly covered by xdr that we are simply providing an extension to xdr in the spirit of the marshalling we could even use a simpler construct such as xdr union a more powerful argument is that allowing arbitrary memoizing of large items can let the caller place almost arbitrary loads on the storage requirements of the callee it could be argued that the callee can reset the connection at any time if the load becomes too onerous via terminateconnection neither of these arguments seems overwhelmingly powerful  url forms open issues we need to specify a default object type and default cinfo the exact format of typeid values and cinfo stacks must also be specified the form of serverid should also be defined to allow slash characters internally should serverid be stylized in a way which makes it easy to use with dns how should http urls be integrated into this if at all should we have multiple url forms with some information about the cinfo being integrated into some of the forms for example henrik has suggested that a url of the form httpngfoobarcomobjectid might be used to indicate that object objectid is available at foobarcom and that the client should use some protocol negotiation protocol to work out the exact shape of the cinfo proposed urls for httpng objects will be of the form wngserveridinstancehandletypetypecinfocinfo where serverid is a identifier for the server which supports the desired object instancehandle is a serverrelative name for the object type is the type id for the most derived type of the object and cinfo is information about the way in which the object needs to be contacted including information such as whether various transport layers are involved this form has the virtue of becoming a urn if the optional cinfo and type fields are omitted  current syntax of cinfo strings the syntax of cinfo currently follows the ilu definition each cinfo string has the form described below where brackets indicate optionality an alphanumericid is an identifier composed of ascii lowercase alphabetic and numeric characters beginning with a lowercase alphabetic character and a nonunderscorestring is any string of ascii characters not containing the underscore character _ cinfo  pinfo @ tinfostackpinfo  scheme  _ parms scheme  alphanumericidparms  parm  _ parms parm  nonunderscorestring tinfostack  tinfo   tinfostack tinfo  scheme  _ parms   syntax of wng pinfo the current syntax of the pinfo string for the ilu implementation of the wng wire protocol is scheme  wngparms  majorversion   minorversion  where majorversion and minorversion are numbers between  and  if the minorversion is not specified it defaults to   syntax of wmux tinfo the current syntax of the tinfo string for the ilu implementation of the wmux transport layer is scheme  wmuxparms  channel _ endpoint where channel is a protocol id number mux and endpoint is a uuid string for an endpoint the size of the endpoint string must be less than  bytes  syntax of tcp tinfo the current syntax of the tinfo string for the ilu implementation of the tcp transport layer is scheme  tcpparms  host _ port where host is string of less than  bytes indicating the ip address or hostname of the remote machine and port is the tcp port on which the host is listening  syntax of sunrpcrm tinfo the current syntax of the tinfo string for the ilu implementation of the sunrpcrm transport layer is scheme  sunrpcrm no parameters are defined this layer implements the onc rpc recordmarking scheme on top of a reliable byte stream as defined in section  of the onc rpc rfc onc rpc  references rfc  httpinfointernetisieduinnotesrfcfilesrfctxt xdr rfc  httpinfointernetisieduinnotesrfcfilesrfctxt onc rpc rfc  httpinfointernetisieduinnotesrfcfilesrfctxt isl ftpftpparcxeroxcompubiluamanualhtmlmanual_html wdhttpngarchmodel work in progress httpwwwworgtrwdhttpngarchitecture mux work in progress httpwwwworgtrwdmux ilu ftpftpparcxeroxcompubiluamanualhtmlmanual_html  address of author bill janssen xerox palo alto research center  coyote hill rd palo alto ca  phone   fax   email janssen@parcxeroxcom http httpwwwparcxeroxcomistlmembersjanssen index a aliased types marshalling of alignment array of byte marshalling of array types marshalling of author b bigendian boolean boolean pseudoc enum type boolean type marshalling of byte order c cinfo marshalling of connection definition of contact info marshalling of controlmsgtype pseudoc enum type d defaultcharsetmsgheader pseudoc struct type discriminant object id memoizing discriminant identification of discriminantid pseudoc struct type e enumeration types marshalling of extension headers f fixedpoint types marshalling of flagged variablelength opaque data xdr type floatingpointvaluetype xdr type g generalfloatingpointvalue xdr type graceful connection shutdown h httpngwngextensionheader isl type httpngwngextensionheaderlist isl type httpngwngsimplestring isl type i implementationlimit system exception initializeconnection message initializeconnectionmsgheader pseudoc struct type instance handle instance handle marshalling of integer types marshalling of interface invalidtype system exception islxdr mapping m marshal system exception marshalling of data memoizing memoizing of pickle and object types messageoriented transport messages description of model of operation n normalfloatingpointvalue xdr type nosuchmethod system exception nosuchobject system exception nosuchobjecttype system exception o object id object state marshalling of object types marshalling of operation id memoizing operation identification of operationid pseudoc struct type optional types marshalling of p padding pickle types marshalling of protocolversion pseudoc struct type pseudoc syntax definition of r record types marshalling of rejected system exception reliable sequenced message transport remote object types marshalling of reply message replymsgheader pseudoc struct type replystatus pseudoc enum type request message requestmsgheader pseudoc struct type s security sequence of byte marshalling of sequence types marshalling of sequenced transport serial numbers discussion of serial numbers range of server id session context statesequence xdr type string types marshalling of success subtype of reply switchconnectioncinfo system exception syntax used system exceptions systemexception subtype of reply t terminateconnection message terminateconnectionmsgheader pseudoc struct type terminationcause pseudoc enum type transport requirements typestate xdr type u union types marshalling of unknownproblem system exception unused pseudoc alias type userexception subtype of reply w wng url form x xdr type remoteobjectinfo xdr internet rfc  use of