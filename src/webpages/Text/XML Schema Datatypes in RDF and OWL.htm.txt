xml schema datatypes in rdf and owl xml schema datatypes in rdf and owl wc working group note  march  this version httpwwwworgtrnoteswbpxschdatatypes latest version httpwwwworgtrswbpxschdatatypes previous version httpwwwworgtrwdswbpxschdatatypes editors jeremy j carroll hp lab jeff z pan university of aberdeen copyright  wc mit ercim keio all rights reserved wc liability trademark and document use rules apply abstract the rdf and owl recommendations use the simple types from xml schema this document addresses three questions left unanswered by these recommendations which uriref should be used to refer to a user defined datatype which values of which xml schema simple types are the same how to use the problematic xsdduration in rdf and owl in addition we further describe how to integrate owl dl with user defined datatypes in appendix b status of this document this section describes the status of this document at the time of its publication other documents may supersede this document a list of current wc publications and the latest revision of this technical report can be found in the wc technical reports index at httpwwwworgtr this document is a working group note produced by the semantic web best practices and deployment working group part of the wc semantic web activity as of the publication of this working group note the swbpd working group has completed work on this document changes from the previous working draft are summarized in appendix c comments on this document may be sent to publicswbpwg@worg a mailing list with a public archive further discussion on this material may be sent to the semantic web interest group mailing list semanticweb@worg also with a public archive this document was produced by a group operating under the  february  wc patent policy this document is informative only wc has a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent publication as a working group note does not imply endorsement by the wc membership this is a draft document and may be updated replaced or obsoleted by other documents at any time it is inappropriate to cite this document as other than work in progress table of contents  introduction  reading this document  namespaces used in this document  xml schema simple types  user defined datatypes  problem statement  component designators solution  using the id attribute  suggested practice  comparison of values  problem statement  all primitive types differ  formal analysis  examples  using sparql for equality  value approximate mapping  duration  the use of numeric types  acknowledgements  references appendix a the semantics of datatyping in the semantic web recommendations a datatypes in rdf a datatypes in owl dl appendix b integrating description logics with userdefined datatypes appendix c changes since working draft of  april   introduction an overview of the datatype abstraction used by rdf is found in the rdf concepts and abstract syntax this is shared by the owl abstract syntax the semantics of rdf datatyping and owl datatyping are summarized in appendix a rdf and owl allow the use of typed literal values in the description of resources and ontologies see the rdf primer and the owl guide for a more introductory treatments for rdf and owl both the rdf semantics and the owl semantics use the lexicaltovalue mapping of the datatype to give the interpretation the value of a typed literal thus the semantics of typed literals is given by the type system the type systems are defined externally to rdf and owl most notably by xml schema concrete syntaxes for typed literals are found in rdf syntax ntriples and n some questions about xml schema datatypes in the semantic web are not directly answered by the published wc recommendations this document considers four of them within rdf and owl how to refer to an xml schema user defined simple type with a uri details of the denotational semantics of the values of the primitive xml schema simple types xml schema principally gives an operational semantics rdf and owl applications need a denotational semantics for interoperable behaviour a possible solution to the problems concerning xsdduration which are reported in rdf semantics appropriate use of numeric types for engineering applications  reading this document while this document can be read from start to finish many readers will benefit from skipping sections the intended reader is informed about rdf andor owl and may be a creator or user of metadata or ontologies or may be an implementor of systems that implement the rdf or owl recommendations or may be the author or editor of related specifications the reader who is interested in defining their own datatypes should read section  and maybe appendix b which gives a formal treatment in terms of owl dl and user defined datatypes that has not been covered by the owl semantics the reader who is interested in the correct use of datatypes should read section  concerning which values are the same and section  concerning numerics particularly but not exclusively for engineering applications implementors probably should read most of the document appendix a summarizes the formal treatment of datatyping from the recommendations section  gives an extended discussion about equality section  discusses the mapping from uris to user defined types readers most interested in formal semantics will find most value in appendix b concerning user defined datatypes and section  concerning equality such readers should start by reviewing appendix a which should be familiar section  on durations is of more limited interest but is significant to any reader who wishes to use implement or build on top of duration datatypes  namespaces used in this document in this document we use n such as xsdint following the subset used by the owl test cases with the following namespace prefixes @prefix dc httppurlorgdcelements @prefix eg httpwwwexampleorg @prefix egdt httpexampleorgsimpletypes @prefix xsd httpwwwexampleorg @prefix rdf httpwwwworgrdfsyntaxns @prefix rdfs httpwwwworgrdfschema @prefix owl httpwwwworgowl @prefix xsd httpwwwworgxmlschema   xml schema simple types xml schema defines facilities for defining simple types to be used in xml schema as well as other xml specifications it is influenced by earlier work on datatypes such as iso  definition an xml schema simple type d is characterised by a value space vd which is a nonempty set a lexical space ld which is a nonempty set of unicode strings and a set of facets fd each of which characterizes a value space along independent axes or dimensions xml schema simple types are divided into disjoint builtin simple types and derived simple types derived datatypes can be defined from primitive or existing derived datatypes by the following three means by restriction ie by using facets on an existing type so as to limit the number of possible values of the derived type by union ie to allow values from a list of simple types by list ie to define the list type of an existing simple type example a the following is the definition of a derived simple type of the base datatype xsdinteger which restricts values to integers greater than or equal to  and less than  using the facets mininclusive and maxexclusive    xsdschema      xsdsimpletype namehumanage       xsdrestriction baseinteger        xsdmininclusive value        xsdmaxexclusive value       xsdrestriction     xsdsimpletype        xsdschema     user defined datatypes xml schema predefines about forty simple types the ones suitable for rdf and owl are listed in rdf semantics in addition xml schema permits users to refine these builtin types by taking a restriction including only some of the values or some of the lexical forms example a as a further example we may wish to talk about ages of adults in years where an adult is over  this can be described as a restriction on the xsdinteger datatype    xsdschema      xsdsimpletype nameadultage       xsdrestriction baseinteger        xsdmininclusive value       xsdrestriction     xsdsimpletype        xsdschema    in a semantic web context this may be used with the objects of triples of an egage property used for instance when describing some members of a club which is restricted to adults eg a nightclub or a political party we will use this example throughout this section and assume it can be retrieved from httpexampleorgsimpletypes within rdf and rdf reasoning this additional restriction may be enough to catch some typos or data entry errors eg putting an inappropriate value of  for the egage property within owl and owl reasoning this may interact with axioms in the ontology to significantly restrict the possible interpretations adding to the modelling power of the language this section only deals with the problem of how to refer to such datatypes their semantics is treated in the appendices appendix a reviews the semantics of datatypes from the rdf and owl recommendations appendix b describes how to integrate description logics such as the shoin dl which is the underpinning of owl dl with user defined datatypes we will also consider the topic of the target namespace from xml schema for clarity we will consider two variants on this example the first has no target namespace the second defines one example b xsschema xmlnsxshttpwwwworgxmlschema  xssimpletype nameadultage    xsrestriction baseinteger     xsmininclusive value    xsrestriction  xssimpletype     xsschema  example c xsschema   targetnamespacehttpexampleorgns  elementformdefaultqualified  xmlnsegnhttpexampleorgns  xmlnsxshttpwwwworgxmlschema  xssimpletype nameadultage    xsrestriction baseinteger     xsmininclusive value    xsrestriction  xssimpletype     xsschema  the case where the xml schema has been assembed from multiple schema documents lies outside the scope of this document this case is discussed in xml schema and explicitly not discussed in xscd  problem statement when describing a resource with rdf or building an ontology with owl in which a user defined simple xml schema datatype such as adultage above what uri should be used to identify this datatype  component designators solution following xml schema component designators xscd example b has uri reference httpexampleorgsimpletypesxscdtypeadultage a uri reference for example c requires a choice of prefix for the namespace httpexampleorgns a good choice is to use the prefix used by the schema itself ie egn the resulting uri reference for the datatype is then httpexampleorgsimpletypesxmlnsegnhttpexampleorgnsxscdtypeegnadultage when the schema does not define a prefix for the target namespace perhaps by using the default namespace then an arbitrary prefix needs to be chosen as always with namespace prefixes it is permitted to use any prefix of your choice even when a conventional prefix is used in the schema document xml schema component designators xscd defines an xpointer scheme that navigates the xml schema document to identify any of the schema components using a fragment this is very general fragments are defined that identify many different aspects of the document including unnamed simple types within complex schema our example b becomes egmembersage rdfsrange httpexampleorgsimpletypesxscdtypeadultage _amember egname jane doe _amember egmembersage httpexampleorgsimpletypesxscdtypeadultage  one way of reading the fragment is that it provides full semantic clarity about what is being identified the xscd shows that an xml schema component is being identified the type indicates that a type is being identified the adultage shows which type is being identified the above urirefs cannot be abbreviated as egmembersage rdfsrange egdtxscdtypeadultage _amember egname jane doe _amember egmembersage egdtxscdtypeadultage  because xscdtypeadultage does not match the ncname production overall referring to xml schema datatypes in the manner proposed by the xml schema working group is a good practice and will be moreso when xscd reaches recommendation status  using the id attribute in cases where the xml schema is under the control of a semantic web author the full generality of xscd is not needed this section shows how when defining your own datatype derived from an xml schema type it is possible to use a simpler method by slightly modifying the schema defining the datatype example a becomes    xsdschema      xsdsimpletype idadultage nameadultage       xsdrestriction baseinteger        xsdmininclusive value       xsdrestriction     xsdsimpletype        xsdschema the difference is that the datatype we wish to use is not only identified by the @name attribute but also by an @id attribute while it is technically possibly to use different values for these two attributes it would be confusing the uri reference httpexampleorgsimpletypesadultage can then be used to refer to the datatype in the terminology of rfc  the uri httpexampleorgsimpletypesadultage identifies a secondary resource when httpexampleorgsimpletypes is retrieved as an xml schema document with mimetype applicationxml this may be taken as a shorthand pointer from the xpointer framework this identifies a view on the xml representation of the primary resource being the xml element with the matching @id attribute when used in rdf see rdf concepts this uri reference may be understood with the uri httpexampleorgsimpletypes as identifying the schema and the uri httpexampleorgsimpletypesadultage as identifying the datatype itself a resource defined or described by the representation identified by the applicationxml retrieval it is preferred that no targetnamespace is given in the schema for this usage if there is no @id attribute with the given name the xpointer framework is clear that this is an error if no element information item is identified by a shorthand pointers ncname the pointer is in error our example rdf is egmembersage rdfsrange httpexampleorgsimpletypesadultage _amember egname jane doe _amember egmembersage httpexampleorgsimpletypesadultage  or egmembersage rdfsrange egdtadultage _amember egname jane doe _amember egmembersage egdtadultage  as a further example a club which has members of all ages but wishes to have a class of its adult members could use an owl expression like the following in the owl abstract syntax classadultmembers   insersectionof     members     restrictionegmembersage allvaluesfromegdtadultage    suggested practice when referring to arbitrary user defined datatypes in arbitrary xml schema the xscd solution is appropriate when an rdf or owl author or tool is writing an xml schema for use with an rdfxml document the @id solution may be preferred  comparison of values two different authors publishing the same information on the semantic web may make different syntactic choices they then say the same thing in different ways this is seen most clearly when the two documents entail one another as determined by the rdf semantics or owl semantics one aspect of the syntactic choices facing an author is which datatypes to use even if they use only the built in xml schema simple types there are nontrivial choices and different authors may legitimately choose different datatypes this section addresses the issue of how implementations of rdf semantics and owl semantics should allow for the different choices of datatype made by different authors  problem statement what is the relationship between the value spaces of the various xml schema builtin simple types when used within rdf and owl or in other words when do two literals which are written down differently refer to the same value for example xsdinteger and xsdinteger both denote the integer ten  all primitive types differ the most appropriate solution is that all primitive xml schema datatypes are treated as having disjoint value spaces this approach is both easy to understand and easy to implement formally in a unary datatype group value spaces of primitive base datatypes are required to be defined as disjoint with each other for instance if the value space datatype d is a subset of that of the datatype d then d and d can not be both primitive base datatypes in a unary datatype group  formal analysis in discussing the examples we presented pairs of literals which denoted the same value this relationship of denoting the same value forms an equivalence relation which we will write as  it is conventionally written as  and called equality it is reflexive symmetric and transitive in terms of the rdf semantics see appendix a the equivalence relation  can be constructed from the interpretation function il in the following way    xy  ilxily for any x y  lv  in terms of owl semantics see appendix a this can be constructed in terms of the interpretation function ed as    xy  edxedy for any x y  lv  a key term we will use in the following examples is primitive base datatype in a type system a recursive definition is each built in primitive datatype is its own primitive base datatype the primitive base datatype of a derived simple type is the primitive base datatype of its base datatype in other words the primitive base datatype of a type system is found by walking up the restriction tree until reaching a primitive type note that the concept of primitive base datatypes in a type system is slightly different from the concept of primitive base datatypes in a unary datatype group this is because it is possible that a primitive base datatype of a type system is not in a datatype map but its derived datatypes are for instance in example_b xsdinteger is a primitive base datatype in the unary datatype group g  examples we give two sets of examples the first set of examples depend on comparisons where the primitive base datatype is the same the second set where the primitive base datatype is not however the second set are intended to be slightly counterintuitive and to illustrate limitations in this approach to comparing typed literals each example is presented in two ways as a pair of literals which may or may not denote the same value as a possible entailment technically the intended entailment is a dentailment in terms of rdf semantics or an owl full entailment in terms of the owl semantics similar slightly longer owl dl entailments could be constructed illustrating the same issues  easy examples it is uncontested that in xml schema a datatype derived by restriction refers to a subset of the values of its base datatype and not to different values see xml schema hence two typed literals whose type have the same primitive base datatype and whose lexical forms are equivalent are equal in addition rdf semantics explicitly sanctions identification of rdf plain literals without language tags with corresponding typed literals with datatype xsdstring derived numerics as a first example xsdbyte and xsddecimal both denote the same value fifteen this follows because xsdbyte has primitive base datatype xsddecimal this licenses the following entailment example a egjane egage xsdbyte  entails egjane egage xsddecimal  the same result holds for two types both of which have primitive base datatype decimal for example xsdbyte and xsdnonnegativeinteger both denote fifteen and the entailment example b egjane egage xsdnonnegativeinteger  entails egjane egage xsdbyte  note that xsdbyte is not derived from xsdnonnegativeinteger or vice versa even with intermediate steps derived strings xsdlanguage has primitive base datatype xsdstring thus enusxsdlanguage and enusxsdstring denote the same value and the following entailment holds example c egdoc dclanguage enusxsdlanguage  entails egdoc dclanguage enusxsdstring  however despite the language identifier being case insensitive according to rfc  this case insensitivity is not represented in the datatype so that enusxsdlanguage and enusxsdlanguage denote different values and we have the following nonentailment example d egdoc dclanguage enusxsdlanguage  does not entail egdoc dclanguage enusxsdlanguage  plain strings the rdf semantics says in an informative section the value space and lexicaltovalue mapping of the xsd datatype xsdstring sanctions the identification of typed literals with plain literals without language tags for all character strings which are in the lexical space of the datatype since both of them denote the unicode character string which is displayed in the literal thus enusxsdstring denotes the same as the plain literal enus and the following two entailments hold example e egdoc dclanguage enusxsdstring  entails egdoc dclanguage enus  example f egdoc dclanguage enusxsdlanguage  entails egdoc dclanguage enus   hard examples when the two typed literals being compared have different primitive base datatypes all the values are assumed to be different and entailments do not follow even when this is counterintuitive the number one for instance can be a float a double or a decimal since they all have different primitive base datatypes these are all different float and decimal a human age is conventionally given as an integer number of years except for babies but a float is a plausible alternative representation on april th  jeremy was forty xsdinteger has a different primitive basetype to xsdfloat so that they are not equal and example g egjeremycarroll egageinyears xsdinteger  does not entail egjeremycarroll egageinyears xsdfloat  similarly float and double are different primitive base datatypes and so superficially similar values such as xsdfloat and xsddecimal are different and example h egcar egenginesizeinlitres xsddecimal  does not entail egcar egenginesizeinlitres xsdfloat  float and double as with float and decimal neither float or double is derived from the other thus xsddouble and xsdfloat are treated as not equal and example j egjeremycarroll egageinyears xsddouble  does not entail egjeremycarroll egageinyears xsdfloat  similarly example k egcar egenginesizeinlitres xsddouble  does not entail egcar egenginesizeinlitres xsdfloat  string and anyuri similarly the two types string and anyuri are distinct primitive base datatypes so that despite superficial similarities httpwwwexampleorgdocxsdstring is different from httpwwwexampleorgdocxsdanyuri and example l egdoc dcidentifier httpwwwexampleorgdocxsdanyuri  does not entail egdoc dcidentifier httpwwwexampleorgdocxsdstring  hexbinary and basebinary the final case where the value spaces of two xml schema simple types appear to the same is for xsdhexbinary and xsdbasebinary for both the value space is described as the set of finitelength sequences of binary octets for instance the binary sequence of two octets   ie the bit integer  can be written in hexadecmial as fb in base encoding rfc  this same sequence of two octets is represented as dc despite this the two types hexbinary and basebinary are distinct primitive base datatypes so that fbxsdhexbinary is different from dcxsdbasebinary and example m egdoc egchecksum fbxsdhexbinary  does not entail egdoc egchecksum dcxsdbasebinary   using sparql for equality while some of the nonentailments shown may be counterintuitive it is possible to use sparql to query a graph and retrieve literal values that are similar even if not derived from the same primitive base type for example related to examples h and k given a graph including the following three triples egcar egenginesizeinlitres xsddouble egcar egenginesizeinlitres xsddecimal egcar egenginesizeinlitres xsdfloat  the following sparql query will match all three select  sizewhere    egcar egenginesizeinlitres size           filter size     in the current sparql working draft the mapping from the typed literal as a syntactic object to its corresponding value is done as part of the operation of the  operator in the above query rather than as part of say a dinterpretation from rdf semantics this mapping is specified in functions  operators and being strongly typed is not identical with that specified in rdf semantics  value approximate mapping a different approach better embedded in rdf semantics could enable meaningful mappings among values from different datatypes this could give better foundations for operations such as the type promotion of the xml path language  xpath  and the  operator in sparql mentioned in section  a quick sketch is that we extend the rdf dinterpretation to support value approximate maps as follows definition a value approximate map mapsto is a partial mapping from typed literals to typed literals example n an example value approximate mapping is xsddecimal owlxmapsto xsdfloat  definition given a datatype map d and a value approximate map mapsto the approximate equality aeq is defined as follows aeqsu sutrue if lsdus  lsdus or if mapstosusu and lsdus  lsdus aeqsu sufalse otherwise note that according to the above definition aeqsu sutrue does not imply that su and su are interpreted as the same value lsdus  lsdus the approximate equality is different from equality and is not necessarily symmetric depending on the corresponding value approxiate map the unsymmetry is needed to support eg type promotions in the xml path language  xpath  note that notion of value approxiate mappings is very general  it does not disallow having symmetric mappings between two typed literals in example n one can also specify a value approximate mapping from xsdfloat to xsddecimal to make the mappings between the two typed literals symmetric to sum up applications can specify a value approximate map mapsto and make use of the approximate equality aeq for their purposes  duration the rdf semantics recommendation discourages the use of the xsdduration datatype see xml schema it says some builtin xml schema datatypes are unsuitable for various reasons and should not be used xsdduration does not have a welldefined value space this may be corrected in later revisions of xml schema datatypes in which case the revised datatype would be suitable for use in rdf datatyping the underlying difficulty is the impossibility of an unequivocal answer to the question how many days in a month this has proved problematic in other applications of xml schema datatypes the xquery and xslt working groups have a proposed solution they derive two new datatypes xdtyearmonthduration and xdtdaytimeduration from xsdduration sidestepping the unanswerable question in section  of functions  operators we read definition xdtyearmonthduration is derived from xsduration by restricting its lexical representation to contain only the year and month components the value space of xdtyearmonthduration is the set of xsinteger month values the year and month components of xdtyearmonthduration correspond to the gregorian year and month components defined in section  of iso  respectively and definition xdtdaytimeduration is derived from xsduration by restricting its lexical representation to contain only the days hours minutes and seconds components the value space of xdtdaytimeduration is the set of fractional second values the components of xdtdaytimeduration correspond to the day hour minute and second components defined in section  of iso  respectively these two new datatypes are suitable for use with rdf and owl note that they are not yet recommended since fo is still in working draft  the use of numeric types for much data on the semantic web a motivation for providing type information is to permit the use of the data by engineering applications and interoperation between engineering applications most such data will be marked up using the numeric types from xml schema loss in precision or unexpected changes in values due to automatic type conversion could be problematic in an engineering environment in the engineering domain there are three important types of usage for numerics count measurement and constant count a count is an integer representing essentially the cardinal number for a set of things classified by some set of tests an example would be the count of packages of candy available for shipment a count is an exact number tests may include measurements but a count is not an approximation of a sum of these measurements nor is it a sum of the approximation of these measurements a type such as xsdinteger or a type derived from xsdinteger is appropriate for counts measurement a measurement is an inexact numeric value usually represented as a real produced by some measurement method this value indicates a value range which includes the actual value the actual value is unknowable but more precise measurement methods can reduce the range of uncertainty the precision or uncertainty is usually included with the measurement value either implicitly using significant figures or explicitly using a separate property value such as error range either the xsdfloat or xsddouble datatypes are appropriate for measurement but it should be noted that these do not include a precision or uncertainity which should be included as the value of a separate property xml schema explicitly states for xsddecimal that precision is not reflected in this value space the number  is not distinct from the number  constant a constant is an exact value used in computation it may or may not be possible to express exactly as a numeric a millimeter is exactly  meters but pi is not  often an xsddecimal will be more appropriate than an xsdfloat or xsddouble for expressing a constant example a as an example of a measurement with an error range to indicate a weight in the interval kg kg egjeremycarroll egweight _w _w egunits kilogram _w egvalue xsdfloat _w egerrorrange xsdfloat  these different usages suggest some potential needs and concerns for a type system underlying this because the value spaces for these types are different measurements are disjoint from counts and constants some means of capturing precision or erroruncertainty is needed for measurement values some means is desirable for writing down constants that cannot be expressed precisely in numeric form the first of these issues will generally be reflected in the use of xsdinteger for counts xsdfloat and xsddouble for measurements and xsddecimal for constants the second issue concerning precision of measurements must be addressed at the modelling level by using objects to state precision or error properties for measurements this is not a bad approach in any case since there are often other properties or metadata associated with a measurement for the third issue concerning some constants no solution is offered  acknowledgements evan wallace is the author of section  evan wallace ashok malhotra pat hayes dave peterson dave reynolds michael sperbergmcqueen and ralph swick contributed useful reviews  references rdfsemantics rdf semantics patrick hayes editor wc recommendation  february  httpwwwworgtrrecrdfmt  latest version available at httpwwwworgtrrdfmt  rdf primer rdf primer frank manola and eric miller editors wc recommendation  february  httpwwwworgtrrecrdfprimer  latest version available at httpwwwworgtrrdfprimer  rdf concepts resource description framework rdf concepts and abstract syntax graham klyne and jeremy j carroll editors wc recommendation  february  httpwwwworgtrrecrdfconcepts  latest version available at httpwwwworgtrrdfconcepts  rdf syntax rdfxml syntax specification revised dave beckett editor wc recommendation  february  httpwwwworgtrrecrdfsyntaxgrammar  latest version available at httpwwwworgtrrdfsyntaxgrammar  ntriples rdf test cases jan grant and dave beckett editors wc recommendation  february  httpwwwworgtrrecrdftestcases  latest version available at httpwwwworgtrrdftestcases  owl abstract syntax owl semantics owl web ontology language semantics and abstract syntax peter f patelschneider patrick hayes and ian horrocks editors wc recommendation  february  httpwwwworgtrrecowlsemantics  latest version available at httpwwwworgtrowlsemantics  owl guide owl web ontology language guide michael k smith chris welty and deborah l mcguinness editors wc recommendation  february  httpwwwworgtrrecowlguide  latest version available at httpwwwworgtrowlguide  owl test cases owl web ontology language test cases  jeremy j carroll and jos de roo editors wc recommendation  february  httpwwwworgtrrecowltest latest version available at httpwwwworgtrowltest xpointer framework xpointer framework  paul grosso eve maler jonathan marsh and norman walsh editors wc recommendation  march  httpwwwworgtrrecxptrframework  latest version available at httpwwwworgtrxptrframework  xmlschema xml schema part  structures second edition wc recommendation world wide web consortium henry s thompson david beech murray maloney and noah mendelsohn editors  october  this version is httpwwwworgtrrecxmlschema the latest version is available at httpwwwworgtrxmlschema xmlschema xml schema part  datatypes second edition wc recommendation world wide web consortium paul v biron and ashok malhotra editors  october  this version is httpwwwworgtrrecxmlschema the latest version is available at httpwwwworgtrxmlschema rfc  n freed and n borenstein rfc  multipurpose internet mail extensions mime part one format of internet message bodies  available at httpwwwietforgrfcrfctxt rfc  t bernerslee r fielding and l masinter uniform resource identifiers uri generic syntax ietf rfc  see httpwwwietforgrfcrfctxt rfc  h alvestrand ed rfc  tags for the identification of languages  available at httpwwwietforgrfcrfctxt iso  iso international organization for standardization representations of dates and times  available from httpwwwisoch iso  iso international organization for standardization languageindependent datatypes available from httpwwwisoch unicode the unicode standard version  the unicode consortium addisonwesley  isbn  as updated from time to time by the publication of new versions see httpwwwunicodeorgunicodestandardversions for the latest version and additional information on versions of the standard and of the unicode character database functions  operators xquery  and xpath  functions and operators ashok malhotra jim melton and norman walsh editors world wide web consortium working draft work in progress  september  this version of functions and operators is httpwwwworgtrwdxpathfunctions the latest version of functions and operators is at httpwwwworgtrxpathfunctions xpath  xml path language xpath  anders berglund scott boag don chamberlin mary f fernndez michael kay jonathan robie and jrme simon editors wc candidate recommendation  november  this version of xml path language xpath is httpwwwworgtrcrxpath the latest version of xml path language xpath is at httpwwwworgtrxpath sparql sparql query language for rdf eric prudhommeaux and andy seaborne editors wc working draft  july  httpwwwworgtrwdrdfsparqlquery  latest version available at httpwwwworgtrrdfsparqlquery  xscd xml schema component designators mary holstege and asir s vedamuthu editors wc working draft  march  httpwwwworgtrwdxmlschemaref latest version available at httpwwwworgtrxmlschemaref  pan  description logics reasoning support for the semantic web jeff zpan phd thesis school of computer science the university of manchester  ph  owleu adding customised datatypes into owl jeff zpan and ian horrocks in proc of the second european semantic web conference eswc  pages   an extended version appears in the journal of web semantic  an online version is available at httpwwwwebsemanticsjournalorgpspub n primer getting into rdf  semantic web using n tim bernerslee dan connolly appendix a the semantics of datatyping in the semantic web recommendations a datatypes in rdf according to rdf semantics see section  rdf allows the use of datatypes defined by any external type systems eg the xml schema type system which conform to the following specification definition in rdf a datatype d is characterised by a value space vd which is a nonempty set a lexical space ld which is a nonempty set of unicode strings and a total mapping lvd from the lexical space to the value space this specification allows the use of nonlist xml schema simple types as datatypes in rdf definition all literals have a lexical form being a unicode unicode string typed literals are of the form vu where v is a unicode string called the lexical form of the typed literal and u is a uri reference of a datatype plain literals have a lexical form and optionally a language tag as defined by rfc normalized to lowercase example a boolean is a datatype with value space truefalse lexical space true false and lexicaltovalue mapping truetrue falsefalse true false truexsdboolean is a typed literal while true is a plain literal the associations between datatype uri references eg xsdboolean and datatypes eg boolean can be provided by datatype maps defined as follows definition a datatype map d is a partial mapping from datatype uri references to datatypes an rdfsinterpretation wrt a datatype map d can be defined as follows definition given a datatype map d an rdfs dinterpretation i of a vocabulary v is any rdfsinterpretation of vu ddud which introduces i a distinguished subset lv of ir called the set of literal values which contains all the plain literals in v and ii a mapping il from literals in v into ir and satisfies the following extra conditions lv  icextrdfsliteral for any plain literal plv ilpl  pl for each pair ud where d  du iu  icextrdfsdatatype there exists dir st iu  d icextd  vd  lv for suv iu  d if sld then ilsu  lsds otherwise ilsu  ir  lv if d  icextrdfsdatatype then d irdfsliteral  iextrdfssubclassof a datatypes in owl dl owl full datatyping follows the rdf semantics as above owl dl datatyping is specified in section  of the owl semantics as follows the fundamental difference between rdf datatyping and owl dl datatyping is the relationship between datatypes and classes in owl dl datatypes are not classes and object and datatype domains are disjoint with each other owl allows different owl reasoners to provide different supported datatypes definition given a datatype map d a datatype uri reference u is called a supported datatype uri reference wrt d if there exists a datatype d such that udd in this case d is called a supported datatype wrt d otherwise u is called an unsupported datatype uri reference wrt d owl provides the use of so called enumerated datatypes which are built using literals definition let y  yn be literals an enumerated datatype is of the form oneofy  yn an owl dl dinterpretation wrt a datatype map d can be defined as follows definition an owl dl datatype interpretation wrt to a datatype map d is a pair lved where the datatype domain lv only contains the value spaces for each datatype in d and pl the value space for plain literals ie the union of the set of unicode strings and the set of pairs of unicode strings and language tags and ed is a datatype interpretation function which has to satisfy the following conditions lv  edrdfsliteral for any plain literal pl edpl  pl  pl for each supported datatype uriref u let d  du edu  vd  lv if s  ld then edsu  lvds otherwise edsu is not defined for each unsupported datatype uriref u edu  lv and edsu  edu each enumerated datatype oneofy  yn is interpreted as edy   edyn note that here we simplify the presentation by using ed as the interpretation function for both datatype uri references and literals while owl semantics uses ec for datatypes uri references and l for literals in owl full the disjointness restriction between object and datatype domains is not required appendix b integrating description logics with userdefined datatypes pan  and ph  present a scheme of integrating a large family of decidable description logics including shoin the underpinning of owl dl with unary datatype groups so as to support user defined datatypes a combined dl is decidable if the unary datatype group is conforming a conforming unary datatype group is equipped with a decision procedure for the satisfiability problem of finite conjunctions over supported datatypes definition a unary datatype group g is a triple dbdom where d is a datatype map b is the set of primitive base datatype uri references in g and dom is the declared domain function we call s the set of supported datatype uri references ie for each us du is defined we require b  s the declared domain function dom has the following properties for each u  s if u  b domu  u otherwise domu  v where v  b we assume that there exists a datatype uri reference rdfsxdatatypebottom such that drdfsxdatatypebottom is undefined note that in pan  datatype groups allow arbitrary datatype predicates while here we consider only datatypes which can be regarded as unary datatype predicates example b gdbdom is a unary datatype group where d  xsdinteger  integer xsdstring  string xsdnonnegativeinteger   xsdxintegerlessthann  n b  xsdinteger xsdstring dom  xsdinteger  xsdinteger xsdstring  xsdstring xsdnonnegativeinteger  xsdinteger xsdxintegerlessthann  xsdinteger according to d we have s  xsdinteger xsdstring xsdnonnegativeinteger xsdxintegergreaterthann hence we have b  s note that the value space of n is vn  i  vinteger  i  lsintegern and by n we mean there exists a builtin datatype n for each integer lsintegern in a unary datatype group datatype expressions can be used to represent user defined datatypes definition let g be a unary datatype group the set unary datatype expressions for g abbreviated dexpg is inductively defined as follows let u be a datatype uri reference u  dpexpg let u be a datatype uri reference its relativised negation notu  dpexpg let y  yn be literals the enumerated datatype oneofy  yn  dpexpg for any pq  dpexpg their conjunction andpq  dpexpg for any pq  dpexpg their disjunction orpq  dpexpg example c the xml schema user defined datatype humanage defined in example a can be represented by the following unary datatype expression andxsdnonnegativeinteger xsdxintegerlessthan definition a datatype interpretation of a unary datatype group g  dbdom is a pair lved where the datatype domain lv is a nonempty set and ed is a datatype interpretation function that has to satisfies the following conditions edrdfsliterallv and edrdfsxdatatypebottom   for each plain literal pl edpl  pl  pl and pl  lv for any two primitive base datatype uri references u and u edu  edu   for each supported datatype uri reference u  s let d  du edu  vd  vddomu  lv ldu  lddomu and lsdu  lsddomu if s  ld then edsu  lvds otherwise edsu is not defined for each unsupported datatype uri reference u  s edu  lv and su  edu the datatype interpretation function ed can be extended to provide semantics to unary datatype expressions as follows relativised negations if u  s  d ednotu  eddomu  edu otherwise ednotu  lv  edu enumerated datatypes edoneofy  yn  edy   edyn conjunctions edandpq  edp  edq disjunctions edorpq  edp  edq ph  shows that we can combine any decidable dl including shoin the underpinning of owl dl that provides the conjunction and bottom constructors with a conforming unary datatype group and the combined dl is still decidable appendix c changes since working draft of  april  c typos etc semanitcs in introduction updated syntax for xml schema component designators deleted broken link from description of iso  added reference to iso homepage instead c discussion removal the earlier draft was a discussion document this note is not intended as such so some issues particularly to do with the interactions between various standards recommendations rfcs etc has been removed removed damloil solution removed true values solution removed xpath eq solution moved owl syntax example from damloil section to the end of id section in the xml schema component designator section discussion of relationship between xscd xpointer and rfc  has been removed discussion about the exact semantics of an xscd fragment has been removed deleted words less contentious and moreover  from id solution changed xml schema component designator section to indicate that xscd is a good practice in particular see last paragraph changed discussion subsection on user defined datatypes to suggest that both the remaining solutions are appropriate and have no discussion changed title to suggested practice discussion of harder examples cut down substantially since these are all trivially nonentailments with the agreed semantics removed editors opinion notes c changes in response to comment from ashok malhotra deleted all uses of the word derivation in section  since it has caused confusion added links to the xml schema document for union list and restriction to make it clear that the intended concept is derivation as defined by that document added brief discussion of target namespace after example a providing further examples example b and example c scoped this document to not address xml schema  assembled from multiple schema documents added reference xml schema in the xml schema component designator section added more extended discussion of target namespace issue and added example xscd for schema with target namespace added text showing how the @id solution does comply with the secondary resource concept from rfc  when read in conjunction with rdf concepts xpointer and xml schema c restructuring of section  reordered subsections in section  deleting old   and  and ordering the remaining subsections as follows     followed by renumbering text discussing examples has changed and the change tracking is not detailed moved definition of primitive base datatype from the examples subsection to the formal analysis subsection deleted references to the examples from the new section  was  added example sparql query to show how to use  in sparql to compare across the type hierarchy added an updated discussion of mapsto c other changes added further acknowledgements updated reference to rfc  to be to rfc  updated table of contents removed unused references updated versions of wc wds in references