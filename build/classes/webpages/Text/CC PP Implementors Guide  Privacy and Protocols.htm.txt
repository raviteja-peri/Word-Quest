ccpp implementors guide privacy and protocols ccpp implementors guide privacy and protocols wc working draft  december  this version httpwwwworgtrwdccpptrust latest version httpwwwworgtrccpptrust previous version none editors hidetaka ohto  ohto@worg wcpanasonic lalitha suryanarayana mailtolalitha@trisbccom  sbc johan hjelm  johanhjelm@nrjericssonse ericsson research japan copyright  wc mit inria keio all rights reserved wc liability trademark document use and software licensing rules apply abstract this document gives implementors advice on how to protect the privacy of a ccpp user and outlines how this can be applied using pp in http with the ccpp exchange protocol status of this document this section describes the status of this document at the time of its publication other documents may supersede this document the latest status of this document series is maintained at the wc this document is a very preliminary public working draft made available by the world wide web consortium wc for discussion only it is intended to become a wc note this indicates no endorsement of its content this is work in progress may be updated replaced or obsoleted by other documents at any time a list of current wc working drafts can be found at httpwwwworgtr this document is produced by the ccpp working group member only part of the device independence activity the working group welcomes feedback and discussion preferably on the public mailing list wwwmobile@worg although comments may also be sent to the authors public comments and their responses can be accessed at httplistsworgarchivespublicwwwmobile table of contents not included in this version  introduction ccpp data is not in itself personal ie tied to a named user but since there are a number of ways for the user to be identified as the holder of the profile eg by identity transmision in http parameters or through recognition of the ipnumber or such there is a need for a suggested privacy method for implementors descriptions of single features in a description of a terminal or the users preferences for how that terminal should be used cannot in themselves be used to infringe on a users privacy however when a profile contains a collection of such properties it can be used to personalize information the closer the personalization the bigger risk that the user can be identified from his specific use of the terminal and the bigger the risk of misuse from a privacy standpoint there is also a possible risk that a user can be identified as having certain abilities eg if he constantly requests text in doublesized fonts it is likely that he is hard of seeing and this may be possible to misuse generally speaking a user may not want to share some or all of the data in a ccpp profile and may wish to have control over who receives that information and when origin servers customizing the content should therefore express to the user or user agent regarding their privacy practices with regard to the use of ccpp data so that the user can make a decision on whether or not to share that data with the server pp is a way for an origin server to express the privacy policy it adheres to for the user andor his terminal while the match between pp and ccpp is not perfect and while the intent and implementation of the two are different they can be used together to enhance the privacy protection of the user ccpp is an abbreviation of composite capabilitypreference profiles and is an extensible format based on rdf rdf rdfschema for describing device capabilities and user preferences in general user preferences and device capabilities need to be protected from malicious use but there is no trust management framework for ccpp so far without trust management sensitive information opens to attacks by malicious servers or content providers we do not aim to create new technologies in terms of network security authentication message validation personal privacy protection and cryptography we intend to employ the existing technologies in terms of trust management while considering how to apply such technologies well fit into the use cases of ccpp  scope of this document this document is a discussion document containing implementation advice for developers of services based on ccpp it demonstrates the interactions between ccpp and pp given the current state of implementations however since ccpp only specifies a data structure and not a protocol this work should be taken as future input to a formal specification and currently be seen as advice to implementors only  protocol and transport issues there is currently no ccpp protocol there are a number of proposals but for various reasons the group is not chartered to develop a protocol it will do so as soon as possible but it does require a rechartering meanwhile there are two proposals the ccpp exchange protocol and the whttp protocol note that it would be possible to use the profile header mark baker suggests in draftbakerxhtmlmediaregtxt and draftbakerxhtmlmediaregtxt to reference a ccpp profile the mechanism has been demonstrated by kiniko yasuda of keio university there are two main ways of transporting ccpp over http using the ccpp exchange protocol or using the uaprof whttp protocol  ccpp exchange protocol the ccpp exchange protocol ccppex was presented as a wc note on june   it uses the http extension framework rfc the intent was to provide a framework that was both possible to map into http headers and that can handle defaults as uris the idea was to minimize data transfer over the air a goal that was accomplished as has been demonstrated by kiniko yasuda of keio university ccppex uses two headers one for the defaults and one for the updates profilediffs which are separated using md hashes a third header carries warning information the protocol is documented in the wc note ccpp exchange protocol based on http extension framework the ccpp framework is a mechanism for describing the capabilities and preferences associated with users and user agents accessing the world wide web information about user agents includes the hardware platform system software applications and user preferences the user agent capabilities and preferences can be thought of as metadata or properties and descriptions of the user agents hardware and software the ccpp descriptions are intended to provide information necessary to adapt the content and the content delivery mechanisms to best fit the capabilities and preferences of the user and its agents the major disadvantage of this format is that it is verbose some networks are very slow and this would be a moderately expensive way to handle metadata there are several optimizations possible to help deal with network performance issues one strategy is to use a compressed form of xml and a complementary strategy is to use references uris instead of enumerating each set of attributes a reference can be used to name a collection of attributes such as the hardware platform defaults this has the advantage of enabling the separate fetching and caching of functional subsets another problem is to propagate changes to the current ccpp descriptions to an origin server a gateway or a proxy one solution is to transmit the entire ccpp descriptions with each change this is not ideal for slow networks an alternative is to send only the changes the ccpp exchange protocol does not depend on the profile format that it conveys therefore another profile format besides the ccpp description format could be applied to the ccpp exchange protocol for example a user agent issues a request with uris which address the profile information and if the user agent changes the value of an attribute such as turning sound off only that change is sent together with the uris when an origin server receives the request the origin server inquires of ccpp repositories the ccpp descriptions using the list of uris then the origin server creates a tailored content using the fully enumerated ccpp descriptions the origin server might not obtain the fully enumerated ccpp descriptions when any one of the ccpp repositories is not available in this case it depends on the implementation whether the origin server should respond to the request with a tailored content a nontailored content or an error in any case the origin server should inform the user agent of the fact a warning mechanism has been introduced for this purpose it is likely that an origin server a gateway or a proxy will be concerned with different device capabilities or user preferences for example the origin server may have responsibility to select content according to the users preferred language while the proxy may have responsibility to transform the encoding format of the content therefore gateways or proxies might not forward all profile information to an origin server the ccpp exchange protocol might convey natural language codes within header fieldvalues therefore internationalization issues must be considered the internationalization policy of the ccpp exchange protocol is based on rfc considering how to maintain a session like rtsp rfc is worthwhile from the point of view of minimizing transactions ie the session mechanism could permit the client to avoid resending the elements of the ccpp descriptions that have not changed since the last time the information was transmitted however a session mechanism would reduce cache efficiency and requires maintaining states between a user agent and an origin server an extension declaration is used to indicate that an extension has been applied to a message and possibly to reserve a part of the header namespace identified by a header field prefix the http extension framework introduces two types of extension declaration strength mandatory and optional and two types of extension declaration scope hopbyhop and endtoend which type of the extension declaration strengths andor which type of the extension declaration scopes should be used depends on what the user agent needs to do the strength of the extension declaration should be mandatory if the user agent needs to obtain an error response when a serveran origin server a gateway or a proxy does not comply with the ccpp exchange protocol the strength of the extension declaration should be optional if the user agent needs to obtain the nontailored content when a server does not comply with the ccpp exchange protocol the scope of the extension declaration should be hopbyhop if the user agent has a priori knowledge that the first hop proxy complies with the ccpp exchange protocol the scope of the extension declaration should be endtoend if the user agent has a priori knowledge that the first hop proxy does not comply with the ccpp exchange protocol or the user agent does not use a proxy the profile header field is a requestheader field which conveys a list of references which address ccpp descriptions the grammar for the profile header field is as follows header field grammar profile  profilefieldname  reference profilefieldname  profile reference    absoluteuri  profilediffname   profilediffname  profilediffnumber  profilediffdigest profilediffnumber  digit profilediffdigest  sp  md message digest encoded by base  digit  any usascii digit  the profile header fieldvalue is a list of references each reference in the profile header field represents the corresponding entity of the ccpp description a reference is either an absolute uri or a profilediffname an entity of a ccpp description which is represented by an absoluteuri exists outside of the request and an entity of a ccpp description which is represented by a profilediffname exisits inside of the request ie in the profilediff header field the profilediffname in the profile header field addresses a ccpp description in the corresponding profilediff header within the same request when the profile header field includes a profilediffname the corresponding profilediff header must be included within the same request the main reason why the profilediffname is introduced is to specify the priority of each ccpp description in the profile header fieldvalue the priority is indicated by the order of references ie absoluteuri or profilediffname in the profile header fieldvalue the latest reference in the profile header fieldvalue has the highest priority therefore a ccpp description which is represented by the latest reference can override ccpp descriptions which are represented by the precedent references this is the default behavior in the absence of schema rules all profile information could be represented by absoluteuris in the profile header in this case the profilediff header field does not have to be added to the request on the other hand only one profilediff header can contain all profile information in this case the profile header includes only the profilediffname which indicates the profilediff header  whttp the wap forum uaprof group has defined a transport for ccpp over whttp wireless profiled http it can be found in section  of the uaprof specification in the case where the mobile terminal supports wireless profiled http the profile is transported using meta data defined by this specification the ccpp framework remains unaltered the defined mechanism provides a functional equivalent for the ccpp exchange protocol ccppex but the definition of the syntax and semantics of the transport remains in this specification  using whttp to transport ccpp the following extension headers are defined to transport ccpp in whttp the defined extension headers are considered to be end to end headers  xwapprofile the xwapprofile header is a general header field which must contain the following  a uri referencing the ccpp profile or a reference to a profile difference transported using the xwapprofilediff or a combination of multiple instances of these two types of data this data may be generated by the mobile terminal or attached by an intermediary point in a request to an origin server in the case of push this header may be generated as a response to a request in the case of push this data may be cached however this header must be present in any request or response when uaprof is used the xwapprofile header may contain references to instances of the xwapprofilediff header defined in the following section  each reference contains two parts the sequence number and the profiledigest the sequence number is used to determine the order of how the xwapprofilediff headers should be applied and the digest is used to validate that the profiledesc in the xwapprofilediff header value is correct  xwapprofilediff the xwapprofilediff header is a general header and may be generated by the mobile terminal or an intermediate proxy to enhance or alter the cpi there may be multiple profile differences each profile difference must also have a reference in the xwapprofile header which indicates the order in which differences should be applied this header contains two parts a sequence identifier and the entity which represents the part of the ccpp description that is being enhanced this header may be present in a request or response in the case of push this data may be cached  xwapprofilewarning the xwapprofilewarning header is a general header essentially it is the same as the xwapprofilewarning header in the ccpp exchange protocol its presence indicates the level to which the response has been tailored in relation to profile data that has been supplied in the request this header may be present in a request or response the warning codes that are defined fall into the following categories  xx  reserved   reserved xx  indicates whether the content has been adapted depending on the profile xx  indicates the server is incapable of processing cpi the xwapprofilewarning may have the following values not applied this value must be included if the content has not been tailored and is sent in a representation which is the only representation available in the server content selection applied must be included if the included content has been selected from one of the representations available  content generation applied must be included if the content has been tailored or generated as a result of applying the included profile  transformation applied must be added by an intermediate proxy if it applies any transformation changing the contentcoding based on the cpi data not supported indicates that the entity sending this warning code does not support uaprof  protocol procedures  over the air in this transport variant the headers and their values are not compressed for over the air transmission it is recommended that the hardware and software manufacturer only use the xwapprofile header to indicate an absoluteuri as the reference for cpi for the mobile terminal when transmitted over the air however this specification does not preclude the use xwapprofilediff in this case  combining xwapprofile and xwapprofilediff if the xwapprofilediff header is included the profilediffseq must match a sequence number in the xwapprofile header otherwise the associated profilediffdesc must not be processed the reference to each xwapprofilediff header contains two parts a sequence number which governs the order in which the xwapprofilediff headers are processed and an md message digest which is used to validate the profiledesc which is contained in the xwapprofilediff if either the sequence or the md validation do not match the particular profilediff must be ignored if the xwapprofilediff header is added by an intermediate proxy it must not alter the existing sequence of xwapprofilediff headers the proxy must append using the next available sequence number in numeric order the digest associated with an xwapprofilediff must be generated by applying md message digest algorithm rfc and base algorithm section  in the mime specification rfc to the corresponding profiledesc part of the header fieldvalue the md algorithm takes as input a message of arbitrary length and produces as output a bit fingerprint or message digest of the input the base algorithm takes as input arbitrary binary data and produces as output printable encoding data of the input  relationship with http headers the profile information referred to in the xwapprofile and xwapprofilediff header does not supersede http request or response header information  caching the xwapprofilewarning header must not be used for cache control purposes if a server wishes to indicate a caching dependency based on these headers then hit should use the vary header as defined in section  of the http  specification http  xml protocolsoap how ccpp will be transported and handled in of xml protocolsoap is not clear this is something the working group wishes to investigate further  other protocols the wap forum has provided a mapping to the headers of wsp the wireless session protocol defined in the wap uaprof specification work is also ongoing in gpp to transport ccpp over rsvp use cases  http use case since ccpp is intended to be protocol neutral it will work with any protocol which can transport it mappings have been produced for other protocols most notably wsp however it is to be expected that it will be implemented for http using http headers as a transport the working group also intends to look at the transport of ccpp over soapxml protocol as a future work item  trust mechanisms policy publishing does not bring trust by itself trust has to be obtained in other ways before it is even worth the trouble to publish a policy in this context pp should rather be seen as a means to retrieve the users consent for data storage andor processing it enables the client to retrieve a policy declaration from the server and match this with the preferences of the client however pp is not defined for other protocols than http no other mechanisms exist to our knowledge to communicate policies between client and server note however the known problem that pp does nothing to enforce the policy  this is assumed to take place out of band  using pp with http in the document ccpp exchange protocol ccppex based on http extension framework httpext a mechanism to transport ccpp over http is described this document describes how that interaction could take place given a pp interaction as well before a policy can be exchanged the client must request it from a server if this is not a proxy in a trusted domain the client will expose his profile to a possibly malicious party if the ccpp exchange protocol is used since the profile is sent in its entirety with the first get request thus a malicious server could take this profile and do anything it wanted with it since no relationship has been established one solution to this is to transmit a minimal profile as part of the first request as described in pemi when the policy has been received and approved a full profile is sent as a profilediff note that if the policy is rejected there is currently no way for the server to maintain a state over users requests and there is no way for the server to recognize that the client does not approve of the policy since there is no fallback method in pp note that it is possible for the profile declared to be a null profile ie without content and the correct profile to be transferred as a diff upon approval of the servers policy note also that the state management mechanism in the server is currently is not specified it should be possible to use cookies for this although the ramifications of a discussion of this would lead too far the interaction with pp might have two levels of granularity a where the privacy policy includes all ccpp vocabulary generic statement stating that all data in the profile and profile diff headers will not be retained or misused or will be used only for the purposes of content customization b where the policy specifically states what attributes data elements from the ccpp vocabulary is collected and state the purpose this can be extended at a later date to include negotiation capabilities which is currently out of the scope of pp or alternately the user agent can be smart enough to parse these elements out and send only those attributes as indicated in the policy in the profile and profile diff headers following the acceptable of the sites policy  pp and ccpp vocabularies the pp vocabulary is defined in xml the ccpp vocabularies are defined in rdf using the xml encoding of rdf the pp specification pp declares that an rdf encoding will be made available when this happens pp elements can be used inside ccpp profiles and vice versa for further information on mixing namespaces in profiles see ccpp and ccppvocab since this effort has been advertised the ccpp working group has decided not to create any mapping of their own but await the pp working group efforts an alternative solution is to create a ccpp data schema in the pp syntax but that would seem redundant if an rdf version of pp is forthcoming the two working groups will continue to investigate this  safe zone the pp specification defines a concept of a safe zone this concept does not exist a priori in ccpp since no protocol has been defined however the pimi method as described in section  can be used to provide a safe zone in the way that is indicated in the pp specification section  as noted above an empty profile can be used while negotiating within the safe zone instead of a minimal one  appel no rules language is defined for ccpp existing implementations make use of xslt to predicate transformations using xpath profile documents can be addressed from within a style sheet in the future it is foreseen that there will be a need for a more extensive rule system such that decisions can concern not just the formatting but the content itself as well in that regard synergies with the appel rules language for pp could be investigated  use of trusted intermediaries in the ccpp exchange protocol profiles can be referenced and retrieved by an intermediary a gateway or other proxy it is also possible that this entity could handle the pp negotiations if a mechanism to delegate authority to it existed and endtoend security was not required this may occur in situations where the user is in a trusted domain which is interfaced with the internet through the proxy or gateway in this case the pp negotiation will be terminated in the proxy it will also be necessary for the proxy not just to keep a cache of documents but to maintain a database of user state it may even be necessary for the proxy to become the entity which performs not just transcoding but also personalization on behalf of the origin server the advantage for the user of this would be that the personal information  including the ccpp profile  stays in the trusted proxy the advantage for the origin server owner is harder to identify since the version of the document which has to be delivered will have to be universal and there will not be any record of the number of retrievals who retrieved it etc which conversely can be seen as a privacy enhancement for the user as this type of system continues to emerge eg in the scope of the ietf webi and apex working groups we foresee that the issue will become more important however since the mechanism is transparent to http and since it can be for ccpp we will not discuss it to any further extent here  examples  using pp with ccpp exchange protocol using thepimi method the idea behind the pimi method is that the client has defined a minimal profile with noncontentious information which cannot be used to infringe on the privacy of the client this minimal profile is used in an initial request to get the privacy policy of the server as demonstrated below using the profilediff headers of the ccpp exchange protocol it becomes possible for the client to signal satisfaction or dissatisfaction with the policy by returning a profile difference or not in response to the empty diff the server can provide a document which does not contain the adaption which would have been done using the information which the client will not reveal what constitutes a minimal profile is most likely subjective ultimately the user will have to determine what information he or she wants to give out however for the purposes of discussion we will assume that the properties which enable a generic display and data input on the device without expressing any preferences and without any modifications will constitute a minimum that would imply the following using the properties defined by the wap uaprof drafting committee screen size color capable in this document we propose that an empty diff be sent as response in a second get which would imply that the profile has not changed depending on the implementation the server could return a document containing a different information set than the user would have got if he had accepted the policy or returned nothing this is not specified in the pp specification and out of scope for the ccpp work this would apply when the client initially contacted the server during a session during the rest of the session it would be able to refer to the policy first retrieved or to followup policies which can be added later during a session using the link tag in http using a wellknown location or an http header the interactions would look as follows  client sends request with minimal profile to server this request can be directed to the wellknown location of the pp reference file wcppxml it can also be directed at another location if this has been indicated in a link tag in a document that references this server the reference file is returned after that another request will retrieve the policy file  server returns policy  client reads policy and matches against own rule set  client approves policy sends diff with full information or a get with full information directed at the uri where the document resides if the policy was retrieved from the wellknown or linked location  client receives document  client rejects policy resends request with empty diff  client receives less important document with protocol interactions this would look as follows  client sends request with minimal profile to server         get aresource http        host wwwworg        opt httpwwwworgtrnoteccppexchange  ns        profile httpwwwaaacomhwhttpwwwbbbcomswukhjeaeeemzfsejsyshhg        accept                 acceptlanguage de en  server returns policy         http  ok        pp policyrefhttpcatalogexamplecompppolicyreferencesxml        contenttype texthtml        contentlength         server ccgalaxy  client reads policy and matches against own rule set not shown  client approves policy sends diff with full information          get aresource http         host wwwworg         opthttpwwwworgtrnoteccppexchange  ns                  profilehttpwwwaaacomhwhttpwwwbbbcomswukhjeaeeemzfsejsyshhg           profilediff xml version         rdf xmlnshttpwwwworgtrprrdfsyntax                              xmlnsprfhttpwwwexampleorgtrwdprofilevocabulary                                 description idsoftwareplatform prfsoundon                                  rdf  client receives document not shown  client rejects policy resends request with empty diff          get aresource http         host wwwworg         opthttpwwwworgtrnoteccppexchange  ns                  profilehttpwwwaaacomhwhttpwwwbbbcomswukhjeaeeemzfsejsyshhg           profilediff  client receives less important document not shown  references httpext http extension framework http http rev ccpp composite capabilitypreference profiles ccpp a user side framework for content negotiation rdf resource description framework rdf model and syntax specification rdfschema resource description framework rdf schema specification pp platform for privacy preferences pp project rfc rfc   uniform resource identifiers uri generic syntax ccppex ccpp exchange protocol based on http extension framework pemi privacy enhancements in the mobile internet mikael nilsson helena lindskog simone fischerhuebner karlstad universitypdf format ccppvocab wc note ccpp implementers guide harmonization with existing vocabularies and content transformation heuristics to be appeared appendix basic requirements for trust management frameworks a basic requirements the basic requirements for the ccpp trust management framework which were discussed in the  version of this document are listed below a client must be able to discover the privacy practices of an origin server before revealing private profile information the privacy mechanism must be separable from ccpp framework so that the user has a choice of whether or not privacy mechanism is to be used in other words enable ccpp content negotiation with or without privacy the protocol must allow each client individually to determine what information is private any or all of the profile can be considered private what may be a private piece of information for one user may not be so for another since ccpp is protocol independent the privacy mechanism should also be supported on various transport protocols including http mime smtp etc a client must be able to interact with a server to the point of discovering its privacy policy without having to disclose any particular item of information for example a user agent first sends nonprivate profile data to a server which then responds with a privacy policy as a result of which the user agent may either choose to send or not send any additional private information to the server for the purposes of receiving tailored content it should be possible for the origin server to render content best effort if the private information is not shared by the user intermediate proxies servers and gateways asserting profile data must also honor the privacy needs of the user in other words if the user deems a profile attribute to be private an intermediate proxy must not disclose that attribute in its profile diff may require useragent side privacy capability eg pp user agents must be supported by such servers proxies gateways as with ccpp mechanism the private profile must also support additions and overrides by other network elements as specified in the ccpp specs inline or uri indirect references to the profile information the privacy mechanism should support the split client model thin clients such as for lowend devices on a mobile network for example may not be able to support the necessary mechanism for privacy eg pp user agent perhaps due to overhead such a function should be enabled on a gateway or proxy that acts on behalf of the thin client is this within the scope of our work any requirements relative to pp policy asserted by servers to be in xml versus rdf formats the privacy mechanism must be independent of and separable from security mechanisms in other words it should be possible to transmit private ccpp profile information with or without security the combined system of capability profiles and privacy practice declarations must work in the presence of information caches without leaking private information to parties who have not agreed to treat it properly a pp and the requirements for the trust mechanism this is an analysis of how the proposed use of pp would fulfill the basic requirements for the ccpp trust management framework section  a client must be able to discover the privacy practices of an origin server before revealing private profile information fulfilled provided no private information is transmitted the privacy mechanism must be separable from ccpp framework so that the user has a choice of whether or not privacy mechanism is to be used in other words enable ccpp content negotiation with or without privacy protocol dependent not possible in the examples given the protocol must allow each client individually to determine what information is private any or all of the profile can be considered private what may be a private piece of information for one user may not be so for another fulfilled provided appel a similar rules language or a proprietary solution in the device can be applied to profile construction or various profiles can be selected ie not in this version since ccpp is protocol independent the privacy mechanism should also be supported on various transport protocols including http mime smtp etc not fulfilled pp can be used with other protocols than http as noted in the specification but how has not been specified  a client must be able to interact with a server to the point of discovering its privacy policy without having to disclose any particular item of information for example a user agent first sends nonprivate profile data or an empty profile to a server which then responds with a privacy policy as a result of which the user agent may either choose to send or not send any additional personal information to the server for the purposes of receiving tailored content fulfilled it should be possible for the origin server to render content best effort if the private information is not shared by the user fulfilled intermediate proxies servers and gateways asserting profile data must also honor the privacy needs of the user in other words if the user deems a profile attribute to be private an intermediate proxy must not disclose that attribute in its profile diff fulfilled if the method above is used may require useragent side privacy capability eg pp user agents must be supported by such servers proxies gateways fulfilled although this is actually a strange requirement as with ccpp mechanism the private profile must also support additions and overrides by other network elements as specified in the ccpp specs inline or uri indirect references to the profile information not fulfilled the privacy mechanism should support the split client model thin clients such as for lowend devices on a mobile network for example may not be able to support the necessary mechanism for privacy eg pp user agent perhaps due to overhead such a function should be enabled on a gateway or proxy that acts on behalf of the thin client is this within the scope of our work fulfilled not sure any requirements relative to pp policy asserted by servers to be in xml versus rdf formats not sure what this requirement means the privacy mechanism must be independent of and separable from security mechanisms in other words it should be possible to transmit private ccpp profile information with or without security fulfilled the combined system of capability profiles and privacy practice declarations must work in the presence of information caches without leaking private information to parties who have not agreed to treat it properly not fulfilled since proxies can still be transparent