component extension cx api requirements version  component extension cx api requirements version  wc note  december  this version httpwwwworgtrnotecx latest version httpwwwworgtrcx editors angel diaz ibm jon ferraiolo adobe stein kulseth opera philippe le hgaret wc chris lilley wc charles mccathienevile wc tapas roy openwave ray whitmer netscapeaol copyright  wc mit inria keio all rights reserved wc liability trademark document use and software licensing rules apply abstract from the early days of the world wide web web agents had been extended to support more types of contents the recent developments of xml and the possibility to mix mupltiple xml namespaces in the document reiterated the need to extend implementations and relaying on addon softwares to accomplish tasks not supported by default in the implementation in other words we have several xml languages to represent different parts of web pages xhtml svg mathml xforms etc we now need a well defined mechanism that allow different specialized tools to work together and handled these compound documents this wc note contains a nonexhaustive list of requirements to work on a component extension api the goal of this api is to extend the ability of a web application note that the web application can be either on the server side or on a client side and does not automatically implies interaction with a user or having a web browser status of this document this document is an early draft resulting from the hypertext coordination group face to face meeting to discuss standardization of plugin and active component architecture for the web it is anticipated that this will be published as a wc note as soon as it has reached an appropriate state of maturity this document is a note made available by the wc for discussion only publication of this note by wc indicates no endorsement by wc or the wc team or any wc members there is no commitment by wc to invest additional resources in topics addressed by this note comments on this document are invited and are to be sent to the public mailing list wwwcomponentextension@worg an archive is available at httplistsworgarchivespublicwwwcomponentextension wc technical reports are published online at httpwwwworgtr table of contents  requirements  formatting  baseline and linehight  linebreak size and rectangle negotiation multiple rectangles  dom views and formatting  rendering  freezeunfreeze  zorderpainting  clipping  sharing colormap  sharing fonts  colors accessibility issues  device dependent drawing  forcing redraws invalidate rectangles invalidate region  windowless plugin  style  dom css  specified values  computed values  actual values  generic styler  local styler  mobile profiles  error handling  events  dom core tree  starting point  connecting with outsidescripting  nestingreetrance  abstraction level  timeline  networkhttp  editing  editing mode  associationsregistrationsnegociations  accessibility  versioning  storagepersistence  memory management  security appendices a glossary b references c contributors  requirements this document contains a description of the component extension requirements established during the hypertext cg meeting in august  it classifies the application programming interface api requirements in  categories  the requirement must be addressed by the component extension api  the requirement may be addressed by the component extension api  the requirement is declared out of the scope of the component extension api it might become in its scope in future versions the description of a component extension must be in terms of content that is handled not in terms of a specific piece of software for example it is appropriate to request a component extension that handles svg svg  including some set of functionalities for example identified using the smil required functionalities mechanism for the switch element or the svg equivalent the list of requirements provided in this document is not exhaustive and only reflects the requirements from the hypertext cg meeting  formatting  the host implementation must provide a mechanism for an embedded object to request a region or set of regions for displaying content the formatting interface should be independent of platform specific constraints  baseline and linehight  the host implementation and component extension need to coordinate the linehight and the baseline  linebreak size and rectangle negotiation multiple rectangles  the host shall provide means to determine the maximum size of the rectangle into which the embedded object may render conceptually the size of this page may be unconstrained in both dimensions given scrolling in practice the host must somehow constrain this in at least one dimension for example the host may indicate that this rectangle is scrollable in the linestacking direction it must fix the other dimension typically it would report the current width of its renderable area the embedded object must be permitted to negotiate rectangles and break into smaller areas across lines if need be  dom views and formatting  the dom level  views and formatting should be considered by the component extension api  rendering   freezeunfreeze  a component extension may wish to suspend rendering momentarily while for example a succession of changes are made to the structure or the structure is made temporarily invalid or for some other reason whereby the intermediate state of the document is no to be displayed examples of such methods svg dom svgsvgelement   unsigned long suspendredrawin unsigned long max_wait_milliseconds  void          unsuspendredrawin unsigned long suspend_handle_id                  raisesdomexception  void          unsuspendredrawall  void          forceredraw  void          pauseanimations  void          unpauseanimations                see also section  in svg openwave plugin api pluginsuspend and pluginresume methods  zorderpainting  it should be possible for content which is rendered by component extensions to take its correct place in the zorder of the entire document  it can be above other content such as backgrounds which show through transparent areas and other content later in the document or with higher zorder should be able to partially overlap content rendered by the component extension  clipping  clipping which addresses removal of parts of display elements that lie outside of a given boundary must be addrssed by the component extension  sharing colormap  implementations which require a colormap will need to allow the component extension to request the allocation of colors in the colormap and to find out what colors are already in the colormap and to be notified if the color associated with a particular color index has changed  sharing fonts  the component extension should have access to system fonts and their properties the host implementation provide means for querying metrics of the current font metrics of interest could be a subset of those provided by opentype the host implementation should provide methods for determining glyph bounding boxes baselines and nominal font height it should also provide an indication whether a given character maps to a glyph in that font the component extension should be able to find out about downloadable fonts that other content on the same page has made available and itself to make available fonts that it has downloaded the font properties in use on the parent of the element whose content is being rendered by the component extension should be made available by inheritance over the component extension interface so that the same fonts can be used by the component extension accessibility information about preferred font sizes should be passed across the component extension interface  colors accessibility issues   device dependent drawing  component extension api should provide a platform dependent eg xwindow graphic context microsoft device context method for gathering device dependent information for formatting and drawing into each of the rectangles eg for optimisation of drawing such as window device context fonts however this must not preclude the ability to use device independent methods and the specification should recommend that these are available as a fallback  forcing redraws invalidate rectangles invalidate region  in the component extensiondoescompositing model with direct screen drawing a component extension might damage content rendered by something else this is like the situation in windowing systems where a window is iconised and portions of other windows that are now uncovered have to be told to redraw the containerdoescompositing model with rendering being an offscreen rgba pixmap does not have this problem and need not tell its parents or other component extensions to redraw moving or update of a component extension merely requires recomposition of the current stack of offscreens without the need for a forced redraw though this can be limited to a particular invalidated region issue rectangleregion these descriptions narrowly miss actually listing a requirement make it simpler see also netscape plugins  windowless plugin  component extension which do not draw at all should be addressed by the component extension api see also netscape plugins  style   dom css  this section describes the relation between the component extension api and the document object model dom level  css specification dom level  style sheets and css  specified values  unlike the dom level  css specification dom level  style sheets and css this note does not require access to the specified css values in the style sheets  computed values  if the host implementation provides a dom tree to the component extension and a css style engine the component extension api must have access to the computed css values of its nearest dom node ancestor its parentnode using the dom level  css dom level  style sheets and css viewcss interface depending on the css style engine the host implementation may also provide a fully decorated dom tree for the content addressed by the component extension  actual values  actual css values as defined in the css specification css level  will not be addressed by the component extension api  generic styler  the host implementation should contain a style engine to handle general properties and to provide extension mechanism in order to support other properties this generic styler engine has the responsibility of decorating the dom tree with the computed values see also  computed values languages such as css have mechanism to extend the set of style properties used in the application as an example svg  svg  reused some of the properties listed in the css  specification css level  and adds new ones it is expected that the generic styler of the host implementation supports a specific set of properties and some general style properties such as color background or fonts are required to be supported definition a foreign style property is a style property that is not recognized internally by the generic styler the generic styler does not know its default value or if the value could be inherited or not the generic styler is expected to support foreign style properties the component extension should declare information on style properties it uses that may be foreign to the generic styler such as parse default values inheritance  the styler is responsible for maintaining the information and dealing with duplicate declarations between component extensions a component extension remove style properties or values associated with the style properties in other words the set of style properties stored by the generic styler is the union of the set of style properties supported by the host implementation and its component extensions if a computed value is not recognized the generic styler can use a default value like for colors always make the computed value have two parts a value in first set of values a possible extended value have extended value  callback issue genericstyleengine what to do about style sheets when it is not known what component extension will be loaded  local styler  the component extension can also embedded its own local style engine in this case the component extension does not need to declare or get the computed values of the style properties in a dom tree this model has the advantage to not assume a dom api between the host implementation and the component extension and only applies to the root node of component extension svgsvg mathmath  the local style engine needs to provide access to style sheets access to containing dom tree optional access to the parent information item in order to get the computed values of the style properties propname  value  access to style properties information propname  inheritinitial value   mobile profiles  mobile profiles are always required to be supported by the host implementation and its component extensions  error handling  an error handling mechanism should be provided by the host implementation to the component extension in a future revision of the component extension api this mechanism may be based on or inspired from the error handling mechanism provided by the dom level  core specification dom level  core  events  there must be a way to pass events from the host implementation to the component extension and from the component extension to the host implementation if the host implementation provides a dom tree to the component extension and contains an event mechanism the component extension api must support the dom level  events specification user interface events such as window events or system events reload uri notify events may be addressed namespacebound events are events whose propagation is limited to elements namespace boundaries ie it propagates until it reaches an element who does not use its ancestors namespace name namespace bound events are out of scope  dom core tree  the component extension api must provide programmatic readonly access to html and xml content by conforming to the following modules of the wc document object model level  core specification dom level  core and exporting the interfaces they define the core module for html the core and xml modules for xml  starting point  features of the existing netscape plugin api netscape plugins should considered as a starting point with implementation experience for features of the component extension api which may be modified replaced or eliminated as required to address problems and requirements  connecting with outsidescripting  the component extension will call a host implementation function to request a connection to one of its features this feature may be a generic functionality eg copypaste whether this is selected by button menu item keyboard shortcut dragdrop or  or a specific host implementation chrome eg toolbar button status bar   the request can be to output data through the feature eg status bar title bar alert  to subscribe to events generated from a browser control or to add a control to the chrome eg toolbar menubar menu  the host implementation should return a value indicating whether it allows the connection or not the component extension api should define how the features are selected and specify a minimal list of connections that the browser should allow if it does have the requested feature so that the component extension can reasonably expect such a connection request to be granted subscribedto events can be passed to the component extension using the normal eventpassing mechanism see  events if the connection needs to pass large amounts of data the component extensions stream apis should be used chrome  adding new itemsremoving new items rightclick drop down menumain menu bar status line copypaste find dragdrop focus alert  query user agents capabilities cross plugin streams properties  properties dialog system properties hostname ip   nestingreetrance  it must be possible for a component extension to discover where available and integrate the formatting and rendering of externally supported content types inserted into the component extension dom nodes subhierarchy that are not internally supported by the component extension  abstraction level  much like the wc dom idl descriptions and language bindings the component extension api must be described independent of programming language operating system and platform  timeline  smil  smil  is a specification for synchronized multimedia and smil animation smil animation is a specification for how the timing and animation aspects of smil  can be integrated into other languages such as svg see chapter  in svg if the host implementation supports synchronized playing of media such as audio video or animations then the host implementation must support the ability for timebased component extensions to play media on a portion of a host canvas and the hostplayed media and the component extensionplayed media must be synchronized the api for achieving this synchronization must be rich enough to permit accurate implementation of the syncbehavior and synctolerance attributes defined in the section  in smil  smil  and smil animation allow content to be started and stopped via interactivity such as user interface events eg mouse and keyboard hostsupplied event propagation apis must be such that timebased component extensions can implement the interactivity capabilities defined in the section  basic time support in smil  if the host implementation supports streaming media then the host implementation must supply apis that allow component extensions to receive streaming content  networkhttp  networking support will include an api to request the data from a uri reference the component extension will call a host implementation function and pass the uri reference any additional headers for example in the case of http maybe an additional accept type the method in case of http get put post or head and a pointer to a notify data the component extension may tell the host implementation to use the cache or to override it when the request is complete the host implementation will call the component extensions notify function and pass the data to the component extension using the component extensions stream apis example     kerror hosturirequestkurimethod method                          const char uri                          const char headers                          const char entity                          unsigned long entitysize                          void notifydata                          boolean usecache    void   cxurinotifyconst char uri                       kstatus status                       void notifydata        issue networking in the netscape model netscape plugins the data corresponding to a network request are sent to the component extension by the host implementation by creating a stream it is a callback mechanism should we reused this mechanism or do we want to tie all asynchronous requests with one probably dom event model   editing  many component extensions will involve editing functions so the api must provide a method for access to editing functionalities  character input drawing interfaces etc these must be available in a device independent manner this requirement also means that the available rendering space may need to be dynamically resized see also  linebreak size and rectangle negotiation multiple rectangles  editing mode  the component extension api must provide an interface that allows the notification of the toggle between edit and view modes this api must be present on both the host implementation and the component extension  associationsregistrationsnegociations  in order for the component extension to be able to extend the host dom implementation there must be a way for the component extension to register its own dom implementation in the host dom implementation in that case the dom implementation node factories in document must create dom nodes using the registered component extensions node for the corresponding types only the construction of the dom nodes is affected by the registrations not the building of the dom tree if the component extension does not provide a dom implementation the host implementation must build the entire dom tree itself including for the content addressed by the component extension if the host implementation provides support for xml  xml documents it must also implement the namespaces support defined in the namespaces recommendation xml namespaces namespace conflicts resolution between component extensions must be resolved by the host implementation there must be a way for the user to choose between component extension implementations in case of conflicts the set of functionalities provided by the host implementation must be accessible to the component extension the same applies for the component extension the host implementation must have a way to query the set of functionalities provided by the component extension there are severals ways to extend the host implementation technologies such as xbl or ie behaviors must be considered the group might decide to come up with a modular architecture for an xml parser that will permit some of the xml content to be handled by other component a general stream api should be addressed by the component extension to gain access to their data  accessibility  the component extension api must provide for accessibility requirements substantially this reinforces the need for several of the requirements listed already such as the ability to specify a contenttype rather than a plugin the provision and use of deviceindependent interaction interfaces the user agent accessibility guidelines uuag require that access is provided for dom interfaces and platformspecific interfaces for example msaa the java accessibility api etc where they exist  versioning  the component extension api should have an identifiable versioning mechanism the version information must change each time the functionality is changed i am not sure it is necessary to discuss techniques here as is done in the following paragraph one technique for achieving this is to provide the naming for functionalities and use a mechanism like ccpp for identifying the available functionalities although this seems a little heavy for this purpose and seems to be better suited to using various unstandardized systems rather than for a standardized system  storagepersistence  the host implementation will allow the component extension to save data in persistent storage or a file system this ability will be governed by the security model associated with the component extension for example a web page has the ability to store cookies in the file system of the host but a sandbox model exists there furthermore the user may block web pages from setting cookies the storage functionality can be divided into reading and writing data specific to the component extension private storage example saving high scores in a game storing cookies is an example in the context of a web page reading and writing data from the global data public storage example reading list of addresses or a specific address from an addressbook  for the first item the host implementation may provide the component extension apis to get and set values for example to set hostsetattributenewscore itoanewscore        to read length  hostgetdatasize highscoresif length      scorestring  memalloc length    hostgetattribute highscores scorestring        if the security settings of the component extension do not allow these operations then these operations will fail or the user maybe prompted for advice see also wap persistent storage  memory management  memory management would include apis for allocating a block of memory resizing the block of memory releasing the block of memory and flushing memory from the hosts space issue memory how much memory should a plugin be allowed  probable answer system dependent if the allocation function fails an exception will be generated issue memory what about readwrite if the allocate apis return a pointer as the netscape apis do what will prevent a plugin to do something like           char s  memalloc           s  a          on a system that doesnt have a memory management unit this may freeze the system  security security issues must be considered for each of the functionalities of the component extension api a glossary component extension the term component extension also wellknown as plugins in web browsers refers to any software in charge of providing the clientside part of the component extension api it is a program that runs as part of the host implementation and that is not part of content host implementation the term host implementation refers to any software in charge of providing the serverside part of the component extension api softwares may include web browsers media players component extensions and other programs including assistive technologies that help in retrieving and processing this includes rendering web content application programming interface api an application programming interface api defines how communication may take place between applications it is a set of functions or methods used to access some functionality b references css level  wc world wide web consortium cascading style sheets level  specification may  available at httpwwwworgtrreccss dom level  core wc world wide web consortium document object model level  core specification november  available at httpwwwworgtrrecdomlevelcore dom level  core wc world wide web consortium document object model level  core specification september  available at httpwwwworgtrdomlevelcore dom level  style sheets and css wc world wide web consortium document object model level  views and formatting specification november  available at httpwwwworgtrrecdomlevelstyle dom level  views and formatting wc world wide web consortium document object model level  views and formatting november  available at httpwwwworgtrwddomlevelviews netscape plugins netscape plugin guide  available at httpdevelopernetscapecomdocsmanualscommunicatorpluginindexhtm opentype microsoft opentype specification april  available at httpwwwmicrosoftcomtypographyotspecdefaulthtm rfc ietf internet engineering task force rfc  uniform resource identifiers uri generic syntax eds t bernerslee r fielding l masinter august  available at httpwwwietforgrfcrfctxt svg  wc world wide web consortium scalable vector graphics svg  specification september  available at httpwwwworgtrsvg smil  wc world wide web consortium synchronized multimedia integration language smil  august  available at httpwwwworgtrsmil smil animation wc world wide web consortium smil animation september  available at httpwwwworgtrsmilanimation user agent accessibility guidelines  wc world wide web consortium user agent accessibility guidelines  september  available at httpwwwworgtruaag wap persistent storage wap forum wireless application forum wap persistent storage interface  may  available at httpwwwwapforumorgtechdocumentswappstorapdf xml wc world wide web consortium extensible markup language xml  october  available at httpwwwworgtrrecxml xml information set wc world wide web consortium xml information set august  available at httpwwwworgtrprxmlinfoset xml namespaces wc world wide web consortium namespaces in xml january  available at httpwwwworgtrrecxmlnames c contributors the people who contributed to this document are the members of the hypertext coordination group and the participants of the oslo facetoface meeting jonny axelsson opera bert bos wc angel diaz ibm jon ferraiolo adobe max froumentin wc rick graham bitflash stein kulseth opera dean jackson wc philippe le hgaret wc hkon lie opera rune lillesveen opera chris lilley wc charles mccathienevile wc steven pemberton cwiwc vincent quint wc hypertext cg chair tapas roy openwave peter stark ericksson ray whitmer netscapeaol steve zilles adobe