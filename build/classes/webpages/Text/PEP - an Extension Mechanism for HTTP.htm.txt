pep  an extension mechanism for http wdhttppep pep  an extension mechanism for http wc working draft  november  authors henrik frystyk nielsen dan connolly rohit khare eric prudhommeaux this version httpwwwworgtrwdhttppep id wdhttppephtmlv    fillault exp  latest released version httpwwwworgtrwdhttppep previous versions httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep httpwwwworgtrwdhttppep status of this document this is a wc working draft for review by wc members and other interested parties it is a draft document and may be updated replaced or made obsolete by other documents at any time it is inappropriate to use wc working drafts as reference material or to cite them as other than work in progress a list of current wc working drafts can be found at httpwwwworgtr this wd has also been submitted as ietf id draftietfhttppeptxt the pep specification has gone through a thorough design phase and entered a steady state where the authors do not intend to modify the document any further at the same time we have developed practical experience with the pep demo code available from httpwwwworgprotocolspep which demonstrates both client server and proxy interactions using dynamic loaded pep extensions however we believe that it is essential for a specification to be tested in real world applications before being deployed at large which is the reason for the status as experimental abstract http is used increasingly in applications that need more facilities than the standard version of the protocol provides ranging from distributed authoring collaboration and printing to various remote procedure call mechanisms the protocol extension protocol pep is an extension mechanism designed to address the tension between private agreement and public specification and to accommodate extension of applications such as http clients servers and proxies the pep mechanism is designed to associate each extension with a uri and use a few new rfc  derived header fields to carry the extension identifier and related information between the parties involved in an extended transaction this document defines pep and describes the interactions between pep and http pep is intended to be compatible with http inasmuch as http is compatible with http see  section  it is proposed that the pep extension mechanism be included in future versions of http the pep extension mechanism may be applicable to other information exchange not mentioned in this document it is recommended that readers get acquainted with section  for a suggested reading of this specification and a list of sections specific for http based applications table of contents introduction  requirements  purpose  operational overview  guide to this specification the pep extension space in http notational conventions  bag syntax extension declarations  mapping header fields  the strength of a declaration  endtoend extension declarations  hopbyhop extension declarations extension policy information  the realm of a policy  policy expirations  extra parameters  endtoend policies  hopbyhop policies publishing an extension binding http requests  extending existing http methods  adding new http methods http status codes   policy not fulfilled   bad mapping http proxy servers  proxy servers as endtoend recipients  proxy servers acting on behalf of user agents  proxy servers acting on behalf of origin servers  proxy servers and repeated hopbyhop extensions practical considerations for http  interaction with existing http methods  interaction with existing http headers  server initiated extension declarations security considerations normative references bibliography informative references acknowledgements authors addresses summary of pep interactions examples  client queries server for dav  client informs server about zipflate compression extension  server uses contentdigest extension  server requires client to use payment extension  introduction  requirements http is a generic requestresponse protocol designed to accommodate a variety of applications from network information exchange and searching to file transfer and repository access to query and forms processing most http transactions are initiated by a user agent issuing a request to be applied to a resource on some origin server with intermediaries between them in some cases the origin server replies with a response indicating the result of the transaction semantically however an http transaction is between the principal accessing a resource end user and the principal responsible for the publication of a given resource publisher the publisher is responsible for the service provided at any particular uri for example the mapping between the uri and any representation of the resource to which it refers the end user accesses information provided by a publisher exactly who takes the role as end user or publisher is beyond the scope of this document http as is the case for most transaction based information exchange protocols is used increasingly in applications that need more facilities than the standard version of the protocol provides from distributed authoring collaboration and printing to various remote procedure call mechanisms many extended applications do not require agreement across the whole internet about the extended facilities rather it suffices that conforming peers supporting a particular protocol extension or feature can employ it dynamically with no prior agreement that it is possible for one party having a capability for a new protocol to require that the other party either understand and abide by the new protocol or abort the operation that negotiation of matching capabilities is possible the need for extensibility creates a tension between dynamically extensible applications and public static specifications  purpose the protocol extension protocol pep is an extension mechanism designed to accommodate dynamic extension of http applications by software components and to address the tension between private agreement and public specification the kind of extensions capable of being introduced by pep range from extending a single protocol message introducing new encodings initiating httpderived protocols for new applications to switching to protocols which once initiated run independent of the original protocol stack this document defines the protocol extension mechanism referred to as pep the pep design is the result of analyzing a variety of extensions and extension mechanisms in http and httplike protocols and the motivation behind them the specification also describes the interactions between pep and http including scoping rules and cache semantics pep is intended to be compatible with http inasmuch as http is compatible with http see section  and  and it is proposed that the pep extension mechanism be included in future versions of http  operational overview pep is intended to be used as follows some party designs and specifies an extension the party assigns the extension an identifier which is a uri and makes one or more representations of the extension available at that address see section  a party using a pep compliant agent with an implementation of the extension wishes to use it the agent declares the use of the extension by referencing its uri in a pep extension declaration see section  information about extensions can be passed between agents including information of where they can be used and under what conditions see section  if an extension becomes ubiquitous it may be incorporated into a new version of the base protocol hence transitioning from dynamic extension to static specification in this case applications can refer to the new version of the base protocol instead of the pep extension see section  pep extension declarations are characterized by the following properties they link features introduced by the extension to the uri identifying the extension potentially allowing a recipient to interpret the message correctly with no prior agreement they contain a strength and a scope allowing the sender to define the appropriate action to be taken by the recipient even if it does not understand the semantics of the extension any agent can generate declarations independent of other agents the advantage of including the extension identifier is that at the cost of some extra bytes to spell out the uri the use of a central registry of extension names is avoided pep can also be used to extend applications to support centrally registered extensions assuming a uri is published as part of the registration see section  the pep mechanism is designed to accommodate but does not require dynamic extension of clients servers and proxies by software components as follows clients and servers could be implemented with software component interfaces that allow dynamic installation of extension facilities an implementation compatible with a software component interface supported by the agent could be made available at the uri identifying the extension an agent receiving a message referring to an extension not known by the agent could dereference the extensions identifier and dynamically load support for the extended facility the representation and implementation of dynamic extensible software component interfaces is outside the scope of this specification  guide to this specification this specification is organized as follows section  describes how pep fits into http this is not required reading but may further the understanding of the specification section  is an overview of the notational conventions used throughout the specification section   and  is the core part of the specification describing the generic pep extension mechanism section    and  describe the interactions between pep and http the generic pep extension mechanism may be applicable to other information exchange protocols such mappings however are outside the scope of this specification  the pep extension space in http pep is designed to support dynamic extensibility of http methods headers and status codes before describing in detail how pep does this it is constructive to have a look at how methods headers and status codes behave in http methods the method token in an http request indicates the method to be performed on the resource identified by the requesturi methods need a priori agreement of semantics and can not be extended dynamically if an http server does not know a method it must report an error message see  section  a limitation of the method space is that a request can only contain a single method hence it is not possible to support multiple simultaneous extensions unless having a multiplicity of methods status codes the status code element is a digit integer result code of the attempt to understand and satisfy the request status codes are like method tokens in that there can only be a single status code in a response however status codes are somewhat easier to extend as unknown status codes must be treated as the x code of that class see  section  for example a new status code  my new code would default to  ok headers header fields can be used to pass information about any of the parties involved in the transaction the transaction itself or the resource identified by the requesturi the advantage of headers is that the header space is relatively open compared to that of methods and status codes new headers can be introduced and must be ignored if the recipient does not recognize the header without affecting the outcome of the transaction see  section  in order to achieve the desired flexibility pep is designed to use the header space for describing extensions and not directly http methods or status codes instead pep introduces a placeholder in the method space and status code space respectively guaranteeing that all interactions with existing http applications perform according to the pep specification the two placeholders are a special pep method and a pep method prefix which indicates that a request contains one or more pep extensions that must be adhered to or the transaction aborted see section  a special status code  policy not fulfilled that indicates that the policy for accessing the resource was not met and that further information can be found in the response for diagnosing the problem see section  these two placeholders allow for multiple pep extensions to be deployed simultaneously without overloading the method space or the status code space  notational conventions this specification uses the same notational conventions and basic parsing constructs as rfc  in particular the bnf constructs token quotedstring fieldname uri and deltaseconds in this document are to be interpreted as described in rfc  the key words must must not required shall shall not should should not recommended may and optional in this document are to be interpreted as described in rfc  pep does not rely on particular features defined in urls  that cannot potentially be expressed using urns see section  therefore the more generic term uri is used throughout the specification  bag syntax the bag element is a recursive structure that uses braces  and  to delimit attributevalue pairs that may consist of tokens quotedstrings uris and recursively defined bags the bnf for the bag syntax is as follows     bag               bagname bagitem     bagname          token    bagitem          bag                     token                     quotedstring the bag semantics are defined by its context and the bag name the value of a quoted string may be a uri in some cases unless explicitly defined otherwise all tokens within a bag are caseinsensitive comments as defined by rfc  indicated by surrounding the comment text with parentheses must not be used within a bag construct  extension declarations extension declaration bags are used to indicate the pep extensions that have been applied to a message the grammar for an extension declaration is as follows     extdecl          reqextattr optextattr     reqextattr     map    optextattr     strength                     attributeext    map               map  uri  headerprefix     strength          strength  must  may      attributeext    bag    headerprefix    digit  the map attribute bag contains the uri identifying the extension and a list of any header field names introduced by the extension see section  and  if the extension identifier is relative it is interpreted relative to the base uri of the message as defined by rfc  the strength attribute bag indicates whether the recipient must or may obey the semantics given by the extension or report an error see section  an extension declaration bag extdecl can be extended through the use of one or more attributeext bags unrecognized attributeext bags should be ignored and must not be removed by proxies when forwarding the extension declaration see section  extension declarations can either be hopbyhop or endtoend see  section  depending on the scope of the declaration see section  and  endtoend declarations must be transmitted to the ultimate recipient of the extension declaration hopbyhop declarations are meaningful only for a single transportlevel connection  mapping header fields the headerprefix in a map attribute bag can be used to indicate that all header fields in the message matching the headerprefix value using string prefixmatching are introduced by this extension declaration instance this allows an extension instance to dynamically reserve a part of the header space in the message for introducing new header fields without risking header name conflicts with other extension instances examples of headerprefix values are               agents should not overload wellknown or widely deployed header fields with new semantics unless the new semantics are a superset of the existing semantics so that the header fields still can be interpreted according to the old semantics agents should not reuse already mapped header fields in the same message if a header field is mapped by multiple extension declarations in the same message the recipient should report an error see section  proxies adding extension declarations to a message must make sure that any header fields introduced do not conflict with already mapped header fields in that protocol message see section   the strength of a declaration the strength attribute bag can be used to specify the actions to be taken by the ultimate recipient of the extension declaration the strength value can indicate that the recipient must obey the extension declaration or report an error or the recipient may obey the extension declaration or ignore it altogether if the strength is must the ultimate recipient must consult and adhere to the rules given by the extension when processing the message or report an error see section  and  if the strength is may the ultimate recipient of the extension may consult and adhere to the rules given by the extension when processing the message or ignore the extension declaration completely an agent may not be able to distinguish whether the ultimate recipient does not understand an extension referred to by an extension declaration of strength may or simply ignores the extension declaration if no strength attribute is present the default strength is may not accepting or ignoring an extension declaration is different from not accepting a mapping of header fieldnames introduced by the map attribute bag if the ultimate recipient cannot accept a mapping for example if a fieldname is already mapped by another extension declaration in that protocol message it should report an error see section   endtoend extension declarations endtoend declarations must be transmitted to the ultimate recipient of the declaration the pep header field is an endtoend header field and is defined as follows     pep              pep  extdecl for example     get  http    host somehost    pep map httpwwwworgpepdav if multiple endtoend extensions are declared in the same message the declarations must be listed in the order in which they were applied to the message proxies may under certain conditions act as the ultimate recipient of declarations on behalf of user agents and origin servers see section   hopbyhop extension declarations hopbyhop extension declarations are meaningful only for a single transportlevel connection the cpep header field is a hopbyhop header field and must not be communicated by proxies over further connections the cpep header has the following grammar     cpep            cpep  extdecl for example     get  http    host somehost    cpep map httpwwwworgpepproxyauth     credentials fsdgfag    connection cpep credentials in http the cpep header field must be protected by a connection header by including cpep as a connection header directive the directive must be handled according to the http specification of the connection header see section  and  section  an agent must not send the cpep header field to an http proxy as it does not obey the http rules for parsing the connection header field see  section  if multiple hopbyhop extensions are declared in the same message the extension declarations must be listed in the order in which they were applied hopbyhop cpep declarations must be processed before any endtoend pep declarations  extension policy information extension policy bags are used to indicate the extensions that may be applied to a message extension policies differ from extension declarations in that the latter is information about which extensions have been applied to a message an extension policy is defined as follows     policydecl       reqpolattr optpolattr     reqpolattr     id    optpolattr     for                     maxage                     parameters                     strength                     attributeext     id                id  uri      for               for uriwildcard     maxage           maxage deltaseconds     parameters        params bagitem     uriwildcard      uri   wildcard     wildcard          the id attribute specifies the uri identifying the extension see section  if the extension identifier is relative it is interpreted relative to the base uri of the message as defined by rfc  the for attribute bag specifies which resources the policy is intended for see section  and the maxage attribute bag when the information should be considered stale see section  the params attribute bag can be used to pass additional information about the extension policy see section  the strength attribute indicates whether the policy is a requirement or optional for the resources for which it applies see section  an extension policy bag policydecl can be extended through the use of one or more attributeext bags unrecognized attributeext bags should be ignored and must not be removed by proxies when forwarding the extension policy see section  extension policies can either be hopbyhop or endtoend policies see  section  depending on the scope see section  and  endtoend policies must be transmitted to the ultimate recipient of the extension policy hopbyhop policies are meaningful only for a single transportlevel connection note it is expected that extension policies will be integrated with other metadata initiatives like the rdf initiative  for example  the realm of a policy the for attribute bag can be used to specify the resources identified by uris to which the policy applies this allows extension policies to be deployed to third party sites and to be distributed by other means than directly between the involved parties a uri followed by a lws and a wildcard  represents the set of uris that contains the given uri using prefix matching a uri with no wildcard means that uri only examples of uriwildcards are     for      for httpwwwworgpub     for secretoverviewhtml an empty for attribute bag no bagitems included indicates that the policy is not applied to any resource if no for attribute bag is present the default value is the requesturi a realm can include any number of resources but note that a single wildcard  is not a valid uriwildcard value  policy expirations the maxage attribute bag can be used to specify a datetime after which the recipient should consider the policy stale the maxage attribute bag value indicates that the information should no longer be used if the age is greater than the specified time in seconds see  section  for how to calculate the age a maxage attribute bag cannot be used to force the recipient to discard the policy information its semantics apply only to the caching mechanism of policy information  extra parameters the params attribute bag can be used to include additional information about the extension or modifiers on the use of the extension the params values may or may not be casesensitive depending on the semantics of the parameter name the params attribute bag is defined as a generic bag structure which may be nested no default parameters are defined note pep implementations should pass any parameters to the module or modules handling the particular extension as this may have impact the use of the extension  endtoend policies endtoend policies must be transmitted to the ultimate recipient of a message the pepinfo header field is an endtoend header and is defines as follows     pepinfo          pepinfo  policydecl for example     http  ok    contenttype texthtml    contentlength     pepinfo id httpsomeorgpaymentextension              for cgibinbuy               strength must    doctype html public wcdtd html en     html  proxies may under certain conditions act as the ultimate recipients of extension policies on behalf of user agents and origin servers see section   hopbyhop policies hopbyhop policies are meaningful only for a single transportlevel connection the cpepinfo header field is a hopbyhop header field and must not be communicated by proxies over further connections the cpepinfo header has the following grammar     cpepinfo        cpepinfo  policydecl for example     http  policy not fulfilled    cpepinfo id httpsomeorgprovidestats                 for      connection cpepinfo     in http the cpepinfo header field must be protected by a connection header by including cpepinfo as a connection header directive the directive must be handled according to the http specification of the connection header see section  and  section  an agent must not send the cpepinfo header field to an http proxy as it does not obey the http rules for parsing the connection header field see  section   publishing an extension while the protocol extension definition should be published at the address of the extension identifier this is not a requirement of this specification the only absolute requirement is that distinct names be used for distinct semantics for example one way to achieve this is to use a mid cid or uuid uri the association between the extension identifier and the specification might be made by distributing a specification which references the extension identifier it is strongly recommended that the integrity and persistence of the extension identifier is maintained and kept unquestioned throughout the lifetime of the extension care should be taken not to distribute conflicting specifications that reference the same name even when a uri is used to publish extension specifications care must be taken that the specification made available at that address does not change significantly over time one agent may associate the identifier with the old semantics and another might associate it with the new semantics the extension definition may be made available in different representations ranging from a humanreadable specification defining the extension semantics downloadable code which implements the semantics defined by the extension a formal interface description provided by the extension to a machinereadable specification defining the extension semantics for example a software component that implements the specification may reside at the same address as a humanreadable specification distinguished by content negotiation the humanreadable representation serves to document the extension and encourage deployment while the software component allows clients and servers to be dynamically extended  binding http requests an http request is called a binding request if it includes at least one pep extension declaration of strength must an http server must not return a xx statuscode without obeying all extension declarations of strength must in a binding request this section describes how the binding request mechanism in pep interacts with existing http applications in  section  it is stated that unrecognized header fields should be ignored by the recipient and must be forwarded by proxies hence using a pep or a cpep extension declaration is not sufficient to evoke the correct behavior from existing http agents in a binding request however in  section  method it is said that servers should return  not implemented if the method is unrecognized or not implemented by the server a similar statement is made in  section  it is therefore safe to assume that using the method name will produce the correct result from existing http servers and proxies pep uses the http request method name to extend existing http methods and to introduce new methods see section  in both cases a binding http request invalidates cached entries as described in  section  responses to binding requests are not cachable  extending existing http methods the method name of all http requests containing a pep extension declaration of strength must that semantically extends that method must be prefixed by pep see section  for example a client might express the binding rightsmanagement constraints in an http put request as follows     pepput aresource http    pep map httpwwwworgpeprightsmanagement           strength must    copyright httpwwwworgcopyrighthtml    contributions httpwwwworgpatcheshtml    host wwwworg    contentlength     contenttype texthtml    doctype html  the ultimate recipient of a binding http request with the pep prefix on the method name must process the request by performing the following actions in the order they occur identify all extension declarations both hopbyhop and endtoend of strength must the server may ignore declarations of strength may without affecting the result of the transaction evaluate and process the extensions identified in  in the order they were declared see section  and  or if the extension declarations do not match the policy for accessing the resource then respond with a  policy not fulfilled statuscode see section  strip the pep prefix from the method name and process the reminder of the request according to the semantics of the existing http method name as defined in  the pep prefix is reserved by pep and must not be used by other http extensions  adding new http methods the pep method can be used for all pep extension declarations of strength must that do not naturally extend existing http methods such methods can be address space manipulation extensions like move and copy for example     pep sourcehtml http    pep map httpwwwworgdavmove          strength must    destination destinationhtml    host somehost the pep method indicates that the semantics of this request are defined by one or more pep extension declarations of strength must included in the request the pep method does not have any http message semantics besides being a placeholder for pep extension declarations and hence all other semantics must be defined by the declarations included in the request the ultimate recipient of a pep request must process the request by doing the following identify all extension declarations both hopbyhop and endtoend of strength must the server may ignore declarations of strength may without affecting the result of the transaction evaluate and process the extensions identified in  in the order they were declared see section  and  or if the extension declarations do not match the policy for accessing the resource then respond with a  policy not fulfilled statuscode see section  a successful response should be  ok if the response includes an entity  accepted if the action has not yet been enacted or  no content if the response is ok but does not include an entity if no extension declarations have strength must the response should be  bad request the pep method is reserved by pep and must not be used by other http extensions  http status codes pep introduces two new status codes in addition to the ones already defined by http each statuscode is described below including a description the metainformation required in the response   policy not fulfilled the policy for accessing the resource has not been met in the request the response must include a pepinfo or a cpepinfo header field specifying the extensions required by the publishing party for accessing the resource the server may use the for attribute bag to indicate whether the policy applies to other resources the client may repeat the request using the appropriate extensions if the initial request already included the extensions requested in the  response then the response indicates that access has been refused for those extension declarations if the  response contains the same set of extension policies as the prior response then the client may present any entity included in the response to the user since that entity may include relevant diagnostic information implementers may note the similarity to the way authentication challenges are issued with the  unauthorized statuscode see  section    bad mapping the mappings indicated by one or more map attribute bags in the request were not unique and mapped the same header field more than once the client may repeat the request using a new set of mappings if it believes that it can find a unique set of header fields for which the transaction will succeed  http proxy servers this section describes the role of caching and noncaching proxies and how they interact with pep extensions normally the ultimate recipient of an endtoend extension declaration or an endtoend extension policy is an origin server or a user agent in this case a proxy must forward all components of the extension including declarations policies headers and any methods and status codes defined by this specification in other cases however intermediate caching and noncaching proxies may be authorized to act on behalf of origin servers andor user agents how such an agreement is reached between a party representing the proxy and the party on which behalf it can act is outside the scope of pep but for example the parties may be within the same trust domain  proxy servers as endtoend recipients  proxy servers acting on behalf of user agents in case a proxy is authorized to act as the ultimate recipient on behalf of its proxy clients on endtoend extensions it must obey the following rules the proxy should remove the extension declarations and any header fields that are part of these declarations on which it can act authoritatively before forwarding the response to the proxy client it should issue extension policies for the extensions on which it can act authoritatively as if it was a user agent if an extension declaration added by an http proxy is of strength must the proxy must either prepend the pep method name prefix or use the pep method instead of the method name used in the proxy client request before forwarding the response to the origin server see section  an example of a proxy acting on behalf of one or more user agents is an elementary school wishing to enforce a certain policy for accessing information on the internet the local school proxy can act authoritatively as a retrieval filter on behalf of the pupils instead of having distributed filtering enabled on each of the user agents using the client  proxy servers acting on behalf of origin servers in case a proxy is authorized to act as the ultimate recipient on behalf of an origin server on endtoend extensions it must obey the following rules the proxy should remove the extension declarations and any header fields that are part of these declarations on which it can act authoritatively before forwarding the request to the origin server it should issue extension policies for the extensions on which it can act authoritatively as if it was an origin server if an extension declaration added by an http proxy is of strength must and there are no other extension declarations of strength must in the request the proxy must remove any pep method name prefix before forwarding the request to the origin server see section  if a request uses the pep method the proxy must not forward the request to the origin server unless the communication between the proxy and the origin server can be completed using an existing http method an example of a proxy acting on behalf of an origin server is a corporation having a subscription on an online journal all access to the origin server goes through the corporate firewall that runs a caching proxy server the organization reports to the publisher of the journal on a monthly basis at which point the subscription is reevaluated in the daytoday access the proxy has the authority to act authoritatively on behalf of the origin server registering usage of the journal  proxy servers and repeated hopbyhop extensions if a pep extension is to be used on parts of a message path including user agents origin servers and proxies not covered by endtoend or hopbyhop extension declarations it can be defined as a repeated hopbyhop extension this can for example be the case for a proxy extension applied to a subset of proxies in a message path it is for the designer of the extension to decide whether it can repeat itself on a hopbyhop basis in other words any scope more complex than a hopbyhop or an endtoend scope is a property of the extension and is transparent to pep  practical considerations for http this section describes some practical considerations intended for pep extended http applications the issues described may not apply to other information retrieval protocols  interaction with existing http methods extension designers should consider whether an extension is to work with existing http methods using the pep method token prefix or with the pep method see section  and  this specification does not provide an absolute rule for when to use the pep method compared to the pep method token prefix except that the pep method token prefix is required in situations where intermediate proxies may act authoritatively on behalf of origin servers or user agents see section  and  in case the extension can be used with existing methods then it should be considered whether the extension can be used with any of the existing http methods or only a subset of them some http methods follow the convention of being safe to the requester meaning that they should never have the significance of taking an action other than retrieval see  section  this is for example the case of the get and the head method as pep extension declarations of strength must explicitly modify or replace the method name existing http applications will never be able to mistake a pep enabled message for any of the existing http messages indicated as being safe some extensions may have the property of idempotence in that aside from error or expiration issues the side effects of n   identical extended requests is the same as for a single extended request if this is not the case for a pep extension then it should consider whether it wants to  disable itself on repeated requests andor  inform a user about the behavior of repeating identical requests with this extension  interaction with existing http headers designers of extensions to be used within the http messaging model should consider the interaction with existing http headers especially it should be noted that pep is designed to be compatible with http inasmuch as http is compatible with http see  section  the connection header as described in  section  allows the sender to specify options that are desired for that particular transport connection only all pep hopbyhop extension declarations and policies along with any header fields introduced by extension declarations must be included as connection header directives pep applications must not send any hopbyhop extension declarations or policies to http proxies as they do not obey the rules of http for parsing the connection header field see also  section  the upgrade header  section  allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols pep provides the same functionality but without the need for a central registry of protocol names pep compliant agents may use the  switching protocols status code to switch to httpbased protocols and protocols which once initiated run completely independently of http the content coding values in the contentencoding header as described in  section  indicate an encoding transformation that has been applied to an entity pep provides the same functionality but without the need for a central registry of content codings as both content codings and pep extension declarations are ordered using both may lead to ambiguous situations simultaneous use of both mechanisms is therefore strongly discouraged an origin server can explicitly prevent intermediaries from applying a contentencoding to a resource by using the notransform cachecontrol directive see  section   server initiated extension declarations pep extension declarations can be generated by servers as well as clients if a pep compliant server sends a response with an extension declaration referring to an extension that modifies the message in such a way that the message can not be decoded without using the extension and the corresponding request was either received from a client whose version is lower than http or received with a via header field indicating that it was forwarded by a proxy whose version is lower than http and the response does not already include an expires header then the sender should include an expires header field whose fieldvalue is identical to the fieldvalue of its date header fieldsee  section  if all agents in the message path are http then the sender should use the cachecontrol header field instead of the expires header field to mark the entity uncachable  security considerations the for parameter allows one party to give information about the extensions used by another partys resources the parties may provide resources on different servers or at different addresses on the same server while distinguishing between the parties responsible for different resources at the same server may be infeasible clients should ignore information given by one server about another unless they have reason to trust it or reason to believe that trusting it will have no significant negative consequences dynamic installation of extension facilities as described in the introduction involves software written by one party the provider of the implementation to be executed under the authority of another the party operating the host software this opens the host party to a variety of trojan horse attacks by the provider or a malicious third party that forges implementations under a providers name see for example rfc section  for a discussion of these risks  normative references  d h crocker standard for the format of arpa internet text messages std  rfc  udel august   t bernerslee universal resource identifiers in www a unifying syntax for the expression of names and addresses of objects on the network as used in the worldwide web rfc  cern june   t bernerslee l masinter m mccahill uniform resource locators url rfc  cern xerox parc university of minnesota december   r fielding relative uniform resource locators rfc  uc irvine june   t bernerslee r fielding h frystyk hypertext transfer protocol  http rfc  wcmit uc irvine wcmit may   n freed n borenstein multipurpose internet mail extensions mime part two media types rfc  innosoft first virtual november   r fielding j gettys j c mogul h frystyk t bernerslee hypertext transfer protocol  http rfc  uc irvine dec wcmit dec wcmit wcmit january   d kristol l montulli http state management mechanism rfc  bell laboratories lucent technologies netscape communications february   s bradner key words for use in rfcs to indicate requirement levels rfc  harvard university march   j c mogul r fielding j gettys h frystyk use and interpretation of http version numbers internet draft rfc  dec uc irvine dec wcmit wcmit http working group may   o lassila r swick resource description framework rdf  model and syntax wcnokia wc wc working draft october  this is work in progress  h schulzrinne a rao r lanphier real time streaming protocol rtsp internet draft draftietfmmusicrtsp columbia unetscapeprogressive networks march  this is work in progress  t bernerslee r fielding l masinter uniform resource locators url internet draft draftfieldingurlsyntax wcmit uc irvine xerox corporation may  this is work in progress  bibliography informative references  d eastlake universal payment preamble internet draft drafteastlakeuniversalpayment cybercash march  this is work in progress  d m kristol a proposed extension mechanism for http internet draft draftkristoklhttpextensions january  document expired  jepi selecting payment mechanisms over http internet draft draftkharejepiuppflow wc august  document expired  j miller et al pics label syntax and communication protocols version  wc recommendation recpicslabels wc  october   y goland et al extensions for distributed authoring and versioning internet draft draftjensenwebdavext  march  this is work in progress  n borenstein a user agent configuration mechanism for multimedia mail format information rfc  pp  bellcore september   j klensin n freed m rose e stefferud and d crocker smtp service extensions rfc  mci innosoft dover beach consulting network management associates brandenburg consulting november   d robinson the www common gateway interface version  internet draft draftrobinsonwwwinterface february  document expired  a bairdsmith jigsaw an object oriented server wc note june   h frystyk libwww architecture december   r thau design considerations for the apache server api fifth international world wide web conference may   paris france  netscape corporation the netscape server api  microsoft corporation internet server api documentation  open market inc fastcgi  restoring all cgis good properties  and then some  spyglass spyglass microserver application development interface  j franks wn  a server for the http  roxen introduction to roxen challenger  acknowledgements the pep protocol is the product of a substantial amount of investigation and collaboration dave kristol did some of the first writing on http extension mechanisms jim miller and dave raggett sketched out an initial design which rohit khare wrote up in a number of drafts tim bernerslee anselm bairdsmith paul leach and daniel dardailler deserve special recognition for their efforts in commenting in the design phase of the protocol also thanks to henning schulzrinne anup rao and robert lanphier for pointing out the generalities of pep and providing support for integration with rtsp this specification is a direct reflection of some implementation work a client implementation in  see the htpep module and a server implementation by euisuk chung and anit chakraborty for the jepi project this document has benefited greatly from the comments of all those participating in the httpwg in addition to those already mentioned the following individuals have contributed to this specification euisuk chung don eastlake roy fielding jim gettys yaron goland phill hallambaker paul hoffman koen holtman ora lassila larry masinter and jim whitehead  authors addresses dan connolly architecture domain lead world wide web consortium mit laboratory for computer science  technology square cambridge ma  usa email connolly@worg rohit khare technical staff world wide web consortium mit laboratory for computer science  technology square cambridge ma  usa email khare@worg henrik frystyk nielsen technical staff world wide web consortium mit laboratory for computer science  technology square cambridge ma  usa email frystyk@worg eric prudhommeaux contractor world wide web consortium mit laboratory for computer science  technology square cambridge ma  usa email eric@worg appendices  summary of pep interactions the following tables summarize the outcome of strength and scope rules in pep transactions involving pep compliant and nonpep compliant http proxies and origin servers the summary is intended as a guide and index to the text but is necessarily cryptic and incomplete this summary should never be used or referenced separately from the complete pep specification the tables should be read as follows standard processing the action taken by an ultimate recipient not understanding or ignoring the extension see section  extended processing the action taken by an ultimate recipient understanding and obeying the extension see section  forward extension the action taken by an intermediate party which is not an ultimate recipient see section  strip extension the action taken by an intermediate party which is the ultimate recipient see section   policy not fulfilled the response from an ultimate recipient not understanding or not wishing to obey the extension see section   not implemented the response from an ultimate recipient not understanding the pep method or pep method token prefix see section  table  origin server scope hopbyhop endtoend strength optional may required must optional may required must pep not supported standard processing  not implemented standard processing  not implemented extension not supported standard processing  policy not fulfilled standard processing  policy not fulfilled extension supported extended processing extended processing extended processing extended processing table  proxy server scope hopbyhop endtoend strength optional may required must optional may required must pep not supported strip extension  not implemented forward extension  not implemented extension not supported strip extension  policy not fulfilled forward extension forward extension extension supported extended processing and strip extended processing and strip extended processing and strip extended processing and strip  examples the following examples show various scenarios using pep in http requests and responses information not essential for illustrating the examples is left out referred to as   client queries server for dav in this example the purpose of using pep in the request is to determine whether a server understands and supports the distributed authoring and versioning dav protocol extension  by making the request binding see section  the client forces the server to process the extension declaration and obey the extension or report an error     pepget someurl http    host somehost    pep map httpwwwworgpepdav    http  ok    pepinfo id httpwwwworgpepdav for henrik      the response shows that the server does understand dav and that the client can use it on all resources matching the prefix henrik on that server the policy is informational and other factors like access control may prevent the client from actually using dav on any of these resources pep does not distinguish between querying about or using an extension  the pep declaration is identical whether it in fact is a query may depend on the request method name and request modifiers  client informs server about zipflate compression extension this example shows a client informing a server that it is capable of handling the zipflate compression extension in a response by issuing an extension policy instead of an extension declaration the client indicates that the extension is not used in the request     get index http    host somehost    pepinfo id httpwwwworgpepencoding    http  ok    pep map httpwwwworgpepencoding    cachecontrol notransform    vary      the response shows that the server knows the extension and decides to use it in the response it furthermore includes the notransform cachecontrol directive in order to avoid that proxies add their own contentcoding to the message see section  and a vary header field indicating that a cache may not use the response to reply to a subsequent request without revalidation in this example the client could have used an extension declaration of strength may instead of an extension policy to achieve the same effect the request would not have been affected as the compression applies to message bodies and not headers if the request were to include a message body however the difference would be whether the zipflate extension was applied to that body or not  server uses contentdigest extension this example shows a server applying the contentdigest extension to a response message indicating that the client may ignore it the client has not indicated whether it supports the extension or even if it supports pep     get index http    host somehost    http  ok    pep map httpwwwworgpepdigest     contentdigest abcdefghij    cachecontrol maxage     the response is fully cachable and does not require revalidation when replying to subsequent requests  server requires client to use payment extension the last example shows how a server requires a client to use a micropayment extension in order to access a resource causing an additional roundtrip using the  policy not fulfilled status code see section  the first request does not contain any pep constructs leading to the error message a nonpep compliant client will treat this as a  bad request status code and will not be able to fulfill the servers requirement in a second request see  section      get index http    host somehost     policy not fulfilled    pepinfo id httpwwwworgpepminipayment              params price usd strength must    pepget index http    host somehost    pep map httpwwwworgpepminipayment           strength must    price usd    http  ok     the actual price is passed as an extra parameter in the extension policy the client agrees to the price and issues a new request containing the proper extension declaration if it did not agree with the price it could have tried a lower price and depending on the policy of that resource the server may have responded positively copyright   wc mit inria keio  all rights reserved wc liability trademark document use and software licensing rules apply